-- Load Wind UI Library
local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()

-- Create window
local Window = WindUI:CreateWindow({
    Title = "Moon HUB (Animal Simulator)",
    Icon = "moon",
    Author = "lk_.",
    Folder = "MoonHUB",
    Size = UDim2.fromOffset(580, 460),
    Theme = "Dark",
    SideBarWidth = 170,
    HasOutline = true
})

-- Create tabs
local Tabs = {
    Farm = Window:Tab({Title = "Farm", Icon = "package"}),
    PVP = Window:Tab({Title = "PvP", Icon = "sword"}),
    Teleport = Window:Tab({Title = "Teleport", Icon = "map-pin"}),
    Misc = Window:Tab({Title = "Misc", Icon = "box"}),
    TargetTab = Window:Tab({ Title = "Target", Icon = "circle-user-round"}),
    Scripts = Window:Tab({Title = "Scripts", Icon = "code"}),
    Skins = Window:Tab({Title = "Skins", Icon = "shirt"}),
    Premium = Window:Tab({Title = "Premium", Icon = "gem"}),
    Settings = Window:Tab({Title = "Settings", Icon = "settings"})
}

Window:SelectTab(1)

local Players = game:GetService("Players")
local plr = Players.LocalPlayer

local RS = game:GetService("ReplicatedStorage")
local Events = RS:WaitForChild("Events")
local SpawnEvent = Events:WaitForChild("SpawnEvent")
local PlotSystemRE = RS:WaitForChild("PlotSystemRE")

Tabs.Premium:Section({ Title = "God mode" })

local gmOptions = {
    "Player", "Cow", "Mantis", "Deer", "Pig", "Bear", "Frog",
    "Crab", "Squirrel", "Eagle", "Giraffe", "Horse", "Capybara",
    "Snake", "Croc", "Axo", "Rainbow Chicken", "Black Chicken"
}
local gmSelected = gmOptions[1]

Tabs.Premium:Dropdown({
    Title = "Select Target",
    Values = gmOptions,
    Multi = false,
    Default = gmSelected,
    Callback = function(choice)
        if type(choice) == "table" then
            gmSelected = choice[1] or tostring(choice)
        else
            gmSelected = tostring(choice)
        end
    end
})
Tabs.Premium:Section({ Title = "Instructions" })
Tabs.Premium:Paragraph({
    Title = "How to use",
    Desc = "You must be out of spawn for it to work. Once you're out of spawn, pick a preset animal from the list and press Execute Godmode. This feature is in testing and will be updated to support every animal soon."
})
Tabs.Premium:Button({Title="Execute Godmode",Desc="Run godmode flow",Callback=function()
    local savedPos=plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") and plr.Character.HumanoidRootPart.Position or nil
    local map={Player={"monkey","monke","monkeyAnim"},Cow={"cows","cow3","cowAnim"},Mantis={"mantis","mantis1","mantisAnim"},Deer={"newdeer","deer1","newdeerAnim"},Pig={"pigs","pig2","pigAnim"},Bear={"newbears","babybear3","newbearcubAnim"},Frog={"frog","frog4","frogAnim"},Crab={"crab","crab2","crabAnim"},Squirrel={"squirrel","squirrel5","squirrelAnim"},Eagle={"eagle","eagle9","eagleAnim"},Giraffe={"giraffe","giraffe4","giraffeAnim"},Horse={"newhorse","horse5","newhorseAnim"},Capybara={"capybara","capybara2","capybaraAnim"},Snake={"snakes","snake1","snakeAnim"},Croc={"crocodile","crocodile4","crocodileAnim"},Axo={"axolotl","axolotl3","axolotl_Anim"},["Rainbow Chicken"]={"chicken","chicken13","chickenAnim"},["Black Chicken"]={"chicken","chicken3","chickenAnim"}}
    local spawnArgs=map[gmSelected]
    WindUI:Notify({Title="Godmode",Content="Target: "..tostring(gmSelected).." | Args: "..(spawnArgs and table.concat(spawnArgs, ", ") or "nil"),Duration=2})
    local plotArgs={"buyPlot","2"}
    local targetPos=gmSelected=="Player" and Vector3.new(146,643,427) or nil
    WindUI:Notify({Title="Godmode",Content="Started",Duration=2})
    if plr.Character and plr.Character:FindFirstChildOfClass("Humanoid") then plr.Character:FindFirstChildOfClass("Humanoid").Health=0 end
    local active=true
    task.spawn(function()
        local hrp=nil
        if gmSelected=="Player" then
            while active do
                local char=plr.Character
                hrp=char and char:FindFirstChild("HumanoidRootPart")
                pcall(function() SpawnEvent:FireServer(unpack(spawnArgs)) PlotSystemRE:FireServer(unpack(plotArgs)) end)
                if hrp and targetPos and (hrp.Position-targetPos).Magnitude<1 then break end
                task.wait()
            end
            if active and hrp and savedPos then task.wait(1) hrp.CFrame=CFrame.new(savedPos) WindUI:Notify({Title="Godmode",Content="Returned",Duration=2}) end
        else
            local function fireBoth() pcall(function() SpawnEvent:FireServer(unpack(spawnArgs)) PlotSystemRE:FireServer(unpack(plotArgs)) end) end
            if plr.Character and plr.Character:FindFirstChildOfClass("Humanoid") then plr.Character:FindFirstChildOfClass("Humanoid").Health=0 end
            local tPos=Vector3.new(146,643,427) local close=false local phase1=false
            while active and not phase1 do
                local char=plr.Character hrp=char and char:FindFirstChild("HumanoidRootPart")
                if hrp then local d=(hrp.Position-tPos).Magnitude if d<5 then close=true phase1=true else fireBoth() end end
                task.wait(0.05)
            end
            if active and close then
                local s=tick()
                while active and (tick()-s)<2 do pcall(function() PlotSystemRE:FireServer(unpack(plotArgs)) end) task.wait(0.1) end
            end
            if active and close then
                hrp=plr.Character and plr.Character:FindFirstChild("HumanoidRootPart")
                if hrp then local fd=(hrp.Position-tPos).Magnitude if fd<10 and savedPos then task.wait(1) hrp.CFrame=CFrame.new(savedPos) else WindUI:Notify({Title="Godmode",Content="Failed: "..math.floor(fd),Duration=2}) end end
            end
        end
        active=false
        WindUI:Notify({Title="Godmode",Content="Stopped",Duration=2})
    end)
end})

--================================================================================
-- FLOOD CONFIGURATION
--================================================================================
local numberOfThreads = 10 -- Number of concurrent workers. 25 is very aggressive.
local useWait = true       -- Keep 'true' for stability. Change to 'false' for maximum risk/power.

--================================================================================
-- TOGGLE AND FLOOD LOGIC
--================================================================================



local isFloodActive = false


local activeThreads = {}

local function startFlood()
    
    local success, remoteEvent = pcall(function()
        return game:GetService("ReplicatedStorage"):WaitForChild("ChickenEvent"):WaitForChild("RemoteEvent")
    end)

    if not success then
        warn("WARNING: Could not find 'ChickenEvent'. This flood thread will not start.")
        return 
    end

    
    while isFloodActive do
        remoteEvent:FireServer({["action"] = "shoot"})
        if useWait then
            task.wait()
        end
    end
end

Tabs.Premium:Section({ Title = "Lag Server" })

Tabs.Premium:Section({ Title = "Instructions" })
Tabs.Premium:Paragraph({
    Title = "How to use",
    Desc = "Just activate the option and the entire server will be laggy and frozen for everyone and after deactivating it, wait a while for it to stop completely. This feature is in testing and will be updated to support every animal soon."
})

local LagToggle = Tabs.Premium:Toggle({
    Title = "Lag Server",
    Desc = "Activates/Deactivates the event flood to lag the server.",
    Type = "Checkbox",
    Default = false, 
    Callback = function(state)
        isFloodActive = state

        if isFloodActive then
            -- If the toggle was TURNED ON
            print("======================================================")
            print("[+] Flood ACTIVATED. Starting " .. numberOfThreads .. " threads...")
            print("======================================================")

            -- Clear the old threads table, just in case
            activeThreads = {}

            -- Create and start the new threads
            for i = 1, numberOfThreads do
                local newThread = task.spawn(startFlood)
                table.insert(activeThreads, newThread)
            end
            print(numberOfThreads .. " flood threads are now running.")

        else
            -- If the toggle was TURNED OFF
            print("======================================================")
            print("[-] Flood DEACTIVATED. Stopping all threads...")
            print("======================================================")

            -- Loop through all the threads we created and cancel them
            for i, thread in ipairs(activeThreads) do
                task.cancel(thread) -- Immediately stops the thread's execution
            end

            -- Clear the table to free up memory
            activeThreads = {}
            print("All flood threads have been stopped successfully.")
        end
    end
})

local TargetedPlayer = nil
local ForceWhitelist = ForceWhitelist or {}
local ScriptWhitelist = ScriptWhitelist or {}

-- Variáveis adicionais para o sistema de Target
local Velocity_Asset
pcall(function()
    -- Cria um objeto BodyVelocity para controlar movimento em ações
    Velocity_Asset = Instance.new("BodyVelocity")
    Velocity_Asset.Name = "BreakVelocity"
    Velocity_Asset.MaxForce = Vector3.new(100000, 100000, 100000)
    Velocity_Asset.Velocity = Vector3.new(0, 0, 0)
end)

-- Função para animar o personagem
local function PlayAnim(id, time, speed)
    pcall(function()
        if not plr.Character or not plr.Character:FindFirstChild("Humanoid") then
            WindUI:Notify({
                Title = "Error",
                Content = "Your character is not ready to animate.",
                Duration = 2
            })
            return
        end
        
        plr.Character.Animate.Disabled = false
        local hum = plr.Character.Humanoid
        local animtrack = hum:GetPlayingAnimationTracks()
        for i, track in pairs(animtrack) do
            track:Stop()
        end
        plr.Character.Animate.Disabled = true
        
        local Anim = Instance.new("Animation")
        Anim.AnimationId = "rbxassetid://"..id
        local loadanim = hum:LoadAnimation(Anim)
        loadanim:Play()
        if time then 
            loadanim.TimePosition = time
        end
        if speed then
            loadanim:AdjustSpeed(speed)
        end
        
        loadanim.Stopped:Connect(function()
            plr.Character.Animate.Disabled = false
            for i, track in pairs(animtrack) do
                track:Stop()
            end
        end)
        
        _G.CurrentAnimation = loadanim
    end)
end

-- Função para parar a animação atual
local function StopAnim()
    pcall(function()
        if plr.Character and plr.Character:FindFirstChild("Humanoid") then
            plr.Character.Animate.Disabled = false
            local animtrack = plr.Character.Humanoid:GetPlayingAnimationTracks()
            for i, track in pairs(animtrack) do
                track:Stop()
            end
        end
        
        _G.CurrentAnimation = nil
    end)
end

-- Função para obter o ping do jogador
local function GetPing()
    local ping = 0
    pcall(function()
        ping = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue() / 1000
    end)
    return ping or 0.2
end

-- Função para obter a ferramenta Push
local function GetPush()
    for _, tool in ipairs(plr.Backpack:GetChildren()) do
        if tool.Name == "Push" or tool.Name == "ModdedPush" then
            return tool
        end
    end
    for _, tool in ipairs(plr.Character:GetChildren()) do
        if tool.Name == "Push" or tool.Name == "ModdedPush" then
            return tool
        end
    end
    return nil
end

-- Função para obter jogador pelo nome/display
local function GetPlayer(UserDisplay)
    if UserDisplay and UserDisplay ~= "" then
        for i,v in pairs(Players:GetPlayers()) do
            if v.Name:lower():match(UserDisplay:lower()) or v.DisplayName:lower():match(UserDisplay:lower()) then
                return v
            end
        end
    end
    return nil
end

-- Funções auxiliares Target
local function GetCharacter(Player)
    return Player and Player.Character or nil
end

local function GetRoot(Player)
    local char = GetCharacter(Player)
    if char and char:FindFirstChild("HumanoidRootPart") then
        return char.HumanoidRootPart
    end
    return nil
end

local function TeleportTO(posX,posY,posZ,targetPlayer,method)
    pcall(function()
        local localRoot = GetRoot(plr)
        if not localRoot then return end

        if method == "safe" then
            task.spawn(function()
                for i = 1,30 do
                    task.wait()
                    if localRoot then
                        localRoot.Velocity = Vector3.new(0,0,0)
                        if targetPlayer == "pos" then
                            localRoot.CFrame = CFrame.new(posX,posY,posZ)
                        else
                            local targetRoot = GetRoot(targetPlayer)
                            if targetRoot then
                                localRoot.CFrame = CFrame.new(targetRoot.Position) + Vector3.new(0,2,0)
                            end
                        end
                    end
                end
            end)
        else
            if localRoot then
                localRoot.Velocity = Vector3.new(0,0,0)
                if targetPlayer == "pos" then
                    localRoot.CFrame = CFrame.new(posX,posY,posZ)
                else
                    local targetRoot = GetRoot(targetPlayer)
                    if targetRoot then
                        localRoot.CFrame = CFrame.new(targetRoot.Position) + Vector3.new(0,2,0)
                    end
                end
            end
        end
    end)
end

local function PredictionTP(targetPlayer,method)
    pcall(function()
        local localRoot = GetRoot(plr)
        local targetRoot = GetRoot(targetPlayer)
        if not localRoot or not targetRoot then return end

        local pos = targetRoot.Position
        local vel = targetRoot.Velocity
        local ping = GetPing()

        localRoot.CFrame = CFrame.new(
            (pos.X) + (vel.X) * (ping * 3.5),
            (pos.Y) + (vel.Y) * (ping * 2),
            (pos.Z) + (vel.Z) * (ping * 3.5)
        )

        if method == "safe" then
            task.wait()
            localRoot.CFrame = CFrame.new(pos)
            task.wait()
            localRoot.CFrame = CFrame.new(
                (pos.X) + (vel.X) * (ping * 3.5),
                (pos.Y) + (vel.Y) * (ping * 2),
                (pos.Z) + (vel.Z) * (ping * 3.5)
            )
        end
    end)
end

local function Push(Target)
    -- Implementação da função Push
    pcall(function()
        local Push = GetPush()
        if Push and Push:FindFirstChild("PushTool") then
            local args = {[1] = Target.Character}
            Push.PushTool:FireServer(unpack(args))
            WindUI:Notify({
                Title = "Push",
                Content = "Empurrando " .. Target.Name,
                Duration = 1
            })
        else
            -- Alternativa se não encontrar a ferramenta Push específica
            local targetRoot = GetRoot(Target)
            local localRoot = GetRoot(plr)
            if targetRoot and localRoot then
                local direction = (targetRoot.Position - localRoot.Position).Unit
                local force = Instance.new("BodyVelocity")
                force.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                force.Velocity = direction * 50
                force.Parent = targetRoot
                game.Debris:AddItem(force, 0.2)
                WindUI:Notify({
                    Title = "Push",
                    Content = "Empurrando " .. Target.Name,
                    Duration = 1
                })
            end
        end
        
        -- Reequipar ferramentas necessárias
        for _, toolName in ipairs({"Push", "ModdedPush", "ClickTarget", "potion"}) do
            if plr.Character:FindFirstChild(toolName) then
                local tool = plr.Character:FindFirstChild(toolName)
                tool.Parent = plr.Backpack
                tool.Parent = plr.Character
            end
        end
    end)
end

-- Paragraph para feedback
local targetFeedback = Tabs.TargetTab:Paragraph({
    Title = "Target Status",
    Desc = "No target selected."
})

-- Parágrafo adicional para informações do jogador
local targetInfo = Tabs.TargetTab:Paragraph({
    Title = "Player Information",
    Desc = "Select a target to view information."
})

-- Botão para criar ferramenta de seleção de alvo
local CreateTargetTool = function()
    -- Remove ferramenta antiga se existir
    if plr.Backpack:FindFirstChild("ClickTarget") then
        plr.Backpack:FindFirstChild("ClickTarget"):Destroy()
    end
    if plr.Character and plr.Character:FindFirstChild("ClickTarget") then
        plr.Character:FindFirstChild("ClickTarget"):Destroy()
    end

    local GetTargetTool = Instance.new("Tool")
    GetTargetTool.Name = "ClickTarget"
    GetTargetTool.RequiresHandle = false
    GetTargetTool.TextureId = "rbxassetid://6043845934" -- ID corrigido
    GetTargetTool.ToolTip = "Select Target"
    GetTargetTool.CanBeDropped = false

    GetTargetTool.Activated:Connect(function()
        local mouse = plr:GetMouse()
        local hit = mouse.Target
        local person = nil
        
        if hit and hit.Parent then
            if hit.Parent:IsA("Model") then
                person = Players:GetPlayerFromCharacter(hit.Parent)
            elseif hit.Parent:IsA("Accessory") and hit.Parent.Parent then
                person = Players:GetPlayerFromCharacter(hit.Parent.Parent)
            end
            
            if person and person ~= plr then
                WindUI:Notify({
                    Title = "Target Selected",
                    Content = "Current target: " .. person.Name,
                    Duration = 2
                })
                
                -- Atualizar variável TargetedPlayer diretamente
                TargetedPlayer = person
                
                -- Atualizar feedback
                targetFeedback:SetTitle("Target Selected: " .. person.Name)
                targetFeedback:SetDesc("ID: " .. person.UserId .. "\nName: " .. person.DisplayName)
                
                -- Atualizar informações adicionais do jogador
                local infoText = "Name: " .. person.Name
                infoText = infoText .. "\nDisplay: " .. person.DisplayName
                infoText = infoText .. "\nUserID: " .. person.UserId
                infoText = infoText .. "\nEntered: " .. os.date("%d-%m-%Y", os.time() - person.AccountAge * 24 * 3600)
                
                local team = person.Team and person.Team.Name or "None"
                infoText = infoText .. "\nTeam: " .. team
                
                
                targetInfo:SetTitle("Information: " .. person.Name)
                targetInfo:SetDesc(infoText)
                
                -- Salvar referência global
                _G.TargetedUserId = person.UserId
            elseif person == plr then
                WindUI:Notify({
                    Title = "Error",
                    Content = "You cannot select yourself.",
                    Duration = 2
                })
            else
                -- Limpar alvo
                TargetedPlayer = nil
                _G.TargetedUserId = nil
                
                targetFeedback:SetTitle("Target Status")
                targetFeedback:SetDesc("No target selected.")
                
                targetInfo:SetTitle("Player Information")
                targetInfo:SetDesc("Select a target to view information.")
                
                WindUI:Notify({
                    Title = "Target Removed",
                    Content = "No player selected.",
                    Duration = 2
                })
            end
        end
    end)
    
    GetTargetTool.Parent = plr.Backpack
    GetTargetTool.Parent = plr.Character -- Equipar automaticamente a ferramenta
    
    WindUI:Notify({
        Title = "Tool Created",
        Content = "Use the tool to select a target by clicking on it.",
        Duration = 3
    })
end

Tabs.TargetTab:Button({
    Title = "Grab Selection Tool",
    Desc = "Creates a tool to select targets by clicking on them.",
    Icon = "rbxassetid://6043845934",
    Callback = function()
        CreateTargetTool()
    end
})

Tabs.TargetTab:Section({ Title = "Target Actions" })

-- Botão Visualizar Alvo - Converter para Toggle
Tabs.TargetTab:Toggle({
    Title = "View Target",
    Desc = "Switches the camera to view the target.",
    Value = false,
    Callback = function(state)
        if not TargetedPlayer then
            WindUI:Notify({
                Title = "Error",
                Content = "No target selected.",
                Duration = 2
            })
            return
        end
        
        if state then
            local humanoid = TargetedPlayer.Character and TargetedPlayer.Character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                workspace.CurrentCamera.CameraSubject = humanoid
                
                WindUI:Notify({
                    Title = "Camera",
                    Content = "Viewing " .. TargetedPlayer.Name,
                    Duration = 2
                })
                
                targetFeedback:SetDesc("Viewing " .. TargetedPlayer.Name)
                
                -- Criar loop para manter a visualização
                _G.ViewLoop = task.spawn(function()
                    while _G.ViewingTarget and TargetedPlayer and task.wait(0.5) do
                        pcall(function()
                            if TargetedPlayer.Character and TargetedPlayer.Character:FindFirstChild("Humanoid") then
                                workspace.CurrentCamera.CameraSubject = TargetedPlayer.Character.Humanoid
                            end
                        end)
                    end
                end)
                
                _G.ViewingTarget = true
            else
                WindUI:Notify({
                    Title = "Error",
                    Content = "Could not find target character.",
                    Duration = 2
                })
            end
        else
            _G.ViewingTarget = false
            
            if _G.ViewLoop then
                task.cancel(_G.ViewLoop)
                _G.ViewLoop = nil
            end
            
            pcall(function()
                workspace.CurrentCamera.CameraSubject = plr.Character.Humanoid
            end)
            
            WindUI:Notify({
                Title = "Camera",
                Content = "Returning to normal view.",
                Duration = 2
            })
            
            targetFeedback:SetDesc("Alvo: " .. TargetedPlayer.Name)
        end
    end
})

-- Botão Focar no Alvo - Converter para Toggle
Tabs.TargetTab:Toggle({
    Title = "Focus on the Target",
    Desc = "Follows the target continuously.",
    Value = false,
    Callback = function(state)
        if not TargetedPlayer then
            WindUI:Notify({
                Title = "Error",
                Content = "No target selected.",
                Duration = 2
            })
            return
        end
        
        if state then
            WindUI:Notify({
                Title = "Focus",
                Content = "Following " .. TargetedPlayer.Name,
                Duration = 2
            })
            
            targetFeedback:SetDesc("Focusing on " .. TargetedPlayer.Name)
            
            -- Criar loop para seguir o alvo
            _G.FocusLoop = task.spawn(function()
                _G.FocusingTarget = true
                while _G.FocusingTarget and TargetedPlayer and task.wait(0.2) do
                    pcall(function()
                        TeleportTO(0, 0, 0, TargetedPlayer)
                    end)
                end
            end)
        else
            _G.FocusingTarget = false
            
            if _G.FocusLoop then
                task.cancel(_G.FocusLoop)
                _G.FocusLoop = nil
            end
            
            WindUI:Notify({
                Title = "Focus",
                Content = "Stopped following the target.",
                Duration = 2
            })
            
            targetFeedback:SetDesc("Target: " .. TargetedPlayer.Name)
        end
    end
})

-- Botão Benx no Alvo - Converter para Toggle
Tabs.TargetTab:Toggle({
    Title = "Beng on Target",
    Desc = "Eat the target's ass.",
    Value = false,
    Callback = function(state)
        if not TargetedPlayer then
            WindUI:Notify({
                Title = "Error",
                Content = "No target selected.",
                Duration = 2
            })
            return
        end
        
        if state then
            -- Iniciar animação
            PlayAnim(5918726674, 0, 1)
            
            WindUI:Notify({
                Title = "Benx",
                Content = "Running Benx on " .. TargetedPlayer.Name,
                Duration = 2
            })
            
            targetFeedback:SetDesc("Running Benx on " .. TargetedPlayer.Name)
            
            -- Criar loop para a posição de Benx
            _G.BenxLoop = task.spawn(function()
                _G.BenxingTarget = true
                while _G.BenxingTarget and TargetedPlayer and task.wait() do
                    pcall(function()
                        local localRoot = GetRoot(plr)
                        local targetRoot = GetRoot(TargetedPlayer)
                        
                        if not localRoot:FindFirstChild("BreakVelocity") then
                            local TempV = Velocity_Asset:Clone()
                            TempV.Parent = localRoot
                        end
                        
                        if localRoot and targetRoot then
                            localRoot.CFrame = targetRoot.CFrame * CFrame.new(0, 0, 1.1) -- Posição frontal exata
                            localRoot.Velocity = Vector3.new(0, 0, 0)
                        end
                    end)
                end
                
                -- Limpar ao terminar
                StopAnim()
                pcall(function()
                    if GetRoot(plr):FindFirstChild("BreakVelocity") then
                        GetRoot(plr).BreakVelocity:Destroy()
                    end
                end)
            end)
        else
            _G.BenxingTarget = false
            
            if _G.BenxLoop then
                task.cancel(_G.BenxLoop)
                _G.BenxLoop = nil
            end
            
            -- Parar animação
            StopAnim()
            pcall(function()
                if GetRoot(plr):FindFirstChild("BreakVelocity") then
                    GetRoot(plr).BreakVelocity:Destroy()
                end
            end)
            
            WindUI:Notify({
                Title = "Benx",
                Content = "Stopped running Benx.",
                Duration = 2
            })
            
            targetFeedback:SetDesc("Target: " .. TargetedPlayer.Name)
        end
    end
})

-- Headsit no Alvo - Converter para Toggle
Tabs.TargetTab:Toggle({
    Title = "Headsit on Target",
    Desc = "Sits on the target's head.",
    Value = false,
    Callback = function(state)
        if not TargetedPlayer then
            WindUI:Notify({
                Title = "Error",
                Content = "No target selected.",
                Duration = 2
            })
            return
        end
        
        if state then
            WindUI:Notify({
                Title = "Headsit",
                Content = "Sitting on the head of " .. TargetedPlayer.Name,
                Duration = 2
            })
            
            targetFeedback:SetDesc("Headsit in " .. TargetedPlayer.Name)
            
            -- Criar loop para a posição de Headsit
            _G.HeadsitLoop = task.spawn(function()
                _G.HeadsittingTarget = true
                while _G.HeadsittingTarget and TargetedPlayer and task.wait() do
                    pcall(function()
                        local localRoot = GetRoot(plr)
                        local targetHead = TargetedPlayer.Character and TargetedPlayer.Character:FindFirstChild("Head")
                        
                        if not localRoot:FindFirstChild("BreakVelocity") then
                            local TempV = Velocity_Asset:Clone()
                            TempV.Parent = localRoot
                        end
                        
                        if localRoot and targetHead and plr.Character and plr.Character:FindFirstChild("Humanoid") then
                            plr.Character.Humanoid.Sit = true
                            localRoot.CFrame = targetHead.CFrame * CFrame.new(0, 2, 0)
                            localRoot.Velocity = Vector3.new(0, 0, 0)
                        end
                    end)
                end
                
                -- Limpar ao terminar
                pcall(function()
                    if GetRoot(plr):FindFirstChild("BreakVelocity") then
                        GetRoot(plr).BreakVelocity:Destroy()
                    end
                end)
            end)
        else
            _G.HeadsittingTarget = false
            
            if _G.HeadsitLoop then
                task.cancel(_G.HeadsitLoop)
                _G.HeadsitLoop = nil
            end
            
            pcall(function()
                if GetRoot(plr):FindFirstChild("BreakVelocity") then
                    GetRoot(plr).BreakVelocity:Destroy()
                end
            end)
            
            WindUI:Notify({
                Title = "Headsit",
                Content = "Stopped sitting on the target's head.",
                Duration = 2
            })
            
            targetFeedback:SetDesc("Target: " .. TargetedPlayer.Name)
        end
    end
})

-- Stand ao Lado do Alvo - Converter para Toggle
Tabs.TargetTab:Toggle({
    Title = "Stand Next to the Target",
    Desc = "Stand next to the target.",
    Value = false,
    Callback = function(state)
        if not TargetedPlayer then
            WindUI:Notify({
                Title = "Error",
                Content = "No target selected.",
                Duration = 2
            })
            return
        end
        
        if state then
            -- Iniciar animação de stand
            PlayAnim(13823324057, 4, 0)
            
            WindUI:Notify({
                Title = "Stand",
                Content = "Standing next to " .. TargetedPlayer.Name,
                Duration = 2
            })
            
            targetFeedback:SetDesc("Stand next to " .. TargetedPlayer.Name)
            
            -- Criar loop para a posição de stand
            _G.StandLoop = task.spawn(function()
                _G.StandingTarget = true
                while _G.StandingTarget and TargetedPlayer and task.wait() do
                    pcall(function()
                        local localRoot = GetRoot(plr)
                        local targetRoot = GetRoot(TargetedPlayer)
                        
                        if not localRoot:FindFirstChild("BreakVelocity") then
                            local TempV = Velocity_Asset:Clone()
                            TempV.Parent = localRoot
                        end
                        
                        if localRoot and targetRoot then
                            localRoot.CFrame = targetRoot.CFrame * CFrame.new(-3, 1, 0) -- Posição lateral exata
                            localRoot.Velocity = Vector3.new(0, 0, 0)
                        end
                    end)
                end
                
                -- Limpar ao terminar
                StopAnim()
                pcall(function()
                    if GetRoot(plr):FindFirstChild("BreakVelocity") then
                        GetRoot(plr).BreakVelocity:Destroy()
                    end
                end)
            end)
        else
            _G.StandingTarget = false
            
            if _G.StandLoop then
                task.cancel(_G.StandLoop)
                _G.StandLoop = nil
            end
            
            -- Parar animação
            StopAnim()
            pcall(function()
                if GetRoot(plr):FindFirstChild("BreakVelocity") then
                    GetRoot(plr).BreakVelocity:Destroy()
                end
            end)
            
            WindUI:Notify({
                Title = "Stand",
                Content = "Stopped standing next to the target.",
                Duration = 2
            })
            
            targetFeedback:SetDesc("Target: " .. TargetedPlayer.Name)
        end
    end
})

-- Backpack no Alvo - Converter para Toggle
Tabs.TargetTab:Toggle({
    Title = "Backpack on Target",
    Desc = "Backpack position on target.",
    Value = false,
    Callback = function(state)
        if not TargetedPlayer then
            WindUI:Notify({
                Title = "Error",
                Content = "No target selected.",
                Duration = 2
            })
            return
        end
        
        if state then
            WindUI:Notify({
                Title = "Backpack",
                Content = "Backpack in " .. TargetedPlayer.Name,
                Duration = 2
            })
            
            targetFeedback:SetDesc("Backpack in " .. TargetedPlayer.Name)
            
            -- Criar loop para a posição de backpack
            _G.BackpackLoop = task.spawn(function()
                _G.BackpackingTarget = true
                while _G.BackpackingTarget and TargetedPlayer and task.wait() do
                    pcall(function()
                        local localRoot = GetRoot(plr)
                        local targetRoot = GetRoot(TargetedPlayer)
                        
                        if not localRoot:FindFirstChild("BreakVelocity") then
                            local TempV = Velocity_Asset:Clone()
                            TempV.Parent = localRoot
                        end
                        
                        if localRoot and targetRoot and plr.Character and plr.Character:FindFirstChild("Humanoid") then
                            plr.Character.Humanoid.Sit = true
                            localRoot.CFrame = targetRoot.CFrame * CFrame.new(0, 0, 1.2) * CFrame.Angles(0, -3, 0)
                            localRoot.Velocity = Vector3.new(0, 0, 0)
                        end
                    end)
                end
                
                -- Limpar ao terminar
                pcall(function()
                    if GetRoot(plr):FindFirstChild("BreakVelocity") then
                        GetRoot(plr).BreakVelocity:Destroy()
                    end
                end)
            end)
        else
            _G.BackpackingTarget = false
            
            if _G.BackpackLoop then
                task.cancel(_G.BackpackLoop)
                _G.BackpackLoop = nil
            end
            
            pcall(function()
                if GetRoot(plr):FindFirstChild("BreakVelocity") then
                    GetRoot(plr).BreakVelocity:Destroy()
                end
            end)
            
            WindUI:Notify({
                Title = "Backpack",
                Content = "Stopped backpacking on target.",
                Duration = 2
            })
            
            targetFeedback:SetDesc("Target: " .. TargetedPlayer.Name)
        end
    end
})

-- Doggy no Alvo - Converter para Toggle
Tabs.TargetTab:Toggle({
    Title = "Doggy on Target",
    Desc = "Dog position on target.",
    Value = false,
    Callback = function(state)
        if not TargetedPlayer then
            WindUI:Notify({
                Title = "Error",
                Content = "No target selected.",
                Duration = 2
            })
            return
        end
        
        if state then
            -- Iniciar animação de doggy
            PlayAnim(13694096724, 3.4, 0)
            
            WindUI:Notify({
                Title = "Doggy",
                Content = "Doggy in " .. TargetedPlayer.Name,
                Duration = 2
            })
            
            targetFeedback:SetDesc("Doggy in " .. TargetedPlayer.Name)
            
            -- Criar loop para a posição de doggy
            _G.DoggyLoop = task.spawn(function()
                _G.DoggyingTarget = true
                while _G.DoggyingTarget and TargetedPlayer and task.wait() do
                    pcall(function()
                        local localRoot = GetRoot(plr)
                        local targetLowerTorso = nil
                        
                        -- Tentar obter o LowerTorso diretamente
                        if TargetedPlayer.Character and TargetedPlayer.Character:FindFirstChild("LowerTorso") then
                            targetLowerTorso = TargetedPlayer.Character.LowerTorso
                        end
                        
                        if not targetLowerTorso then
                            -- Fallback para o root se LowerTorso não estiver disponível
                            targetLowerTorso = GetRoot(TargetedPlayer)
                        end
                        
                        if not localRoot:FindFirstChild("BreakVelocity") then
                            local TempV = Velocity_Asset:Clone()
                            TempV.Parent = localRoot
                        end
                        
                        if localRoot and targetLowerTorso then
                            localRoot.CFrame = targetLowerTorso.CFrame * CFrame.new(0, 0.23, 0) -- Posição exata do doggy
                            localRoot.Velocity = Vector3.new(0, 0, 0)
                        end
                    end)
                end
                
                -- Limpar ao terminar
                StopAnim()
                pcall(function()
                    if GetRoot(plr):FindFirstChild("BreakVelocity") then
                        GetRoot(plr).BreakVelocity:Destroy()
                    end
                end)
            end)
        else
            _G.DoggyingTarget = false
            
            if _G.DoggyLoop then
                task.cancel(_G.DoggyLoop)
                _G.DoggyLoop = nil
            end
            
            -- Parar animação
            StopAnim()
            pcall(function()
                if GetRoot(plr):FindFirstChild("BreakVelocity") then
                    GetRoot(plr).BreakVelocity:Destroy()
                end
            end)
            
            WindUI:Notify({
                Title = "Doggy",
                Content = "Stopped doing doggy on target.",
                Duration = 2
            })
            
            targetFeedback:SetDesc("Target: " .. TargetedPlayer.Name)
        end
    end
})

-- Sugar no Alvo - Nova animação
Tabs.TargetTab:Toggle({
    Title = "Suck on Target",
    Desc = "Make the target suck you in.",
    Value = false,
    Callback = function(state)
        if not TargetedPlayer then
            WindUI:Notify({
                Title = "Error",
                Content = "No target selected.",
                Duration = 2
            })
            return
        end
        
        if state then
            -- Usar uma animação de "idle" para manter o personagem reto
            pcall(function()
                if plr.Character and plr.Character:FindFirstChild("Humanoid") then
                    -- Animação de idle/stand
                    PlayAnim(507766666, 0, 0) -- Animação de ficar em pé reto
                    
                    -- Garantir que o personagem não fique inclinado
                    if plr.Character:FindFirstChild("Humanoid") then
                        plr.Character.Humanoid.PlatformStand = true
                    end
                end
            end)
            
            WindUI:Notify({
                Title = "Sugar",
                Content = "Sugar in " .. TargetedPlayer.Name,
                Duration = 2
            })
            
            targetFeedback:SetDesc("Sugar in " .. TargetedPlayer.Name)
            
            -- Variável para controlar a direção do movimento
            local moveDirection = 1
            local moveTimer = 0
            
            -- Criar loop para a posição de sugar
            _G.SugarLoop = task.spawn(function()
                _G.SugaringTarget = true
                while _G.SugaringTarget and TargetedPlayer and task.wait() do
                    pcall(function()
                        local localRoot = GetRoot(plr)
                        local targetHead = nil
                        
                        -- Tentar obter a Head diretamente
                        if TargetedPlayer.Character and TargetedPlayer.Character:FindFirstChild("Head") then
                            targetHead = TargetedPlayer.Character.Head
                        end
                        
                        if not targetHead then
                            -- Fallback para o root se Head não estiver disponível
                            targetHead = GetRoot(TargetedPlayer)
                        end
                        
                        if not localRoot:FindFirstChild("BreakVelocity") then
                            local TempV = Velocity_Asset:Clone()
                            TempV.Parent = localRoot
                        end
                        
                        -- Calcular o offset do movimento para frente e para trás
                        moveTimer = moveTimer + 0.1
                        if moveTimer > 1 then
                            moveDirection = -moveDirection
                            moveTimer = 0
                        end
                        
                        -- Offset adicional para o movimento para frente e para trás
                        local offset = 0.3 * moveDirection
                        
                        if localRoot and targetHead then
                            -- Posicionar um pouco acima da altura do rosto, à frente e com o movimento para frente e para trás
                            -- Usando valores negativos no eixo Z para posicionar na frente do rosto
                            -- Adicionando rotação de 180 graus no eixo Y para virar o personagem na direção do alvo
                            -- Valor Y ajustado para ficar mais para cima (0.7)
                            localRoot.CFrame = targetHead.CFrame * CFrame.new(0, 0.7, -(1.5 + offset)) * CFrame.Angles(0, math.rad(180), 0)
                            localRoot.Velocity = Vector3.new(0, 0, 0)
                        end
                    end)
                end
                
                -- Limpar ao terminar
                StopAnim()
                pcall(function()
                    if GetRoot(plr):FindFirstChild("BreakVelocity") then
                        GetRoot(plr).BreakVelocity:Destroy()
                    end
                end)
            end)
        else
            _G.SugaringTarget = false
            
            if _G.SugarLoop then
                task.cancel(_G.SugarLoop)
                _G.SugarLoop = nil
            end
            
            -- Parar animação e restaurar estado normal do personagem
            StopAnim()
            pcall(function()
                if plr.Character and plr.Character:FindFirstChild("Humanoid") then
                    plr.Character.Humanoid.PlatformStand = false
                end
                
                if GetRoot(plr):FindFirstChild("BreakVelocity") then
                    GetRoot(plr).BreakVelocity:Destroy()
                end
            end)
            
            WindUI:Notify({
                Title = "Suck",
                Content = "Stopped making the target suck you in",
                Duration = 2
            })
            
            targetFeedback:SetDesc("Target: " .. TargetedPlayer.Name)
        end
    end
})

-- Drag no Alvo - Nova animação
Tabs.TargetTab:Toggle({
    Title = "Drag on Target",
    Desc = "Get dragged by the target by the hand.",
    Value = false,
    Callback = function(state)
        if not TargetedPlayer then
            WindUI:Notify({
                Title = "Error",
                Content = "No target selected.",
                Duration = 2
            })
            return
        end
        
        if state then
            -- Usar animação de arrastar
            pcall(function()
                if plr.Character and plr.Character:FindFirstChild("Humanoid") then
                    -- Animação de arrastar (mão estendida)
                    PlayAnim(10714360343, 0.5, 0)
                    
                    -- Garantir que o personagem não fique inclinado
                    if plr.Character:FindFirstChild("Humanoid") then
                        plr.Character.Humanoid.PlatformStand = true
                    end
                end
            end)
            
            WindUI:Notify({
                Title = "Drag",
                Content = "Dragging " .. TargetedPlayer.Name,
                Duration = 2
            })
            
            targetFeedback:SetDesc("Dragging " .. TargetedPlayer.Name)
            
            -- Criar loop para a posição de drag
            _G.DragLoop = task.spawn(function()
                _G.DraggingTarget = true
                while _G.DraggingTarget and TargetedPlayer and task.wait() do
                    pcall(function()
                        local localRoot = GetRoot(plr)
                        local targetRightHand = nil
                        
                        -- Tentar obter a RightHand diretamente
                        if TargetedPlayer.Character and TargetedPlayer.Character:FindFirstChild("RightHand") then
                            targetRightHand = TargetedPlayer.Character.RightHand
                        end
                        
                        if not targetRightHand then
                            -- Fallback para o root se RightHand não estiver disponível
                            targetRightHand = GetRoot(TargetedPlayer)
                        end
                        
                        if not localRoot:FindFirstChild("BreakVelocity") then
                            local TempV = Velocity_Asset:Clone()
                            TempV.Parent = localRoot
                        end
                        
                        if localRoot and targetRightHand then
                            -- Posição específica de arrasto
                            localRoot.CFrame = targetRightHand.CFrame * CFrame.new(0, -2.5, 1) * CFrame.Angles(-2, -3, 0)
                            localRoot.Velocity = Vector3.new(0, 0, 0)
                        end
                    end)
                end
                
                -- Limpar ao terminar
                StopAnim()
                pcall(function()
                    if plr.Character and plr.Character:FindFirstChild("Humanoid") then
                        plr.Character.Humanoid.PlatformStand = false
                    end
                    
                    if GetRoot(plr):FindFirstChild("BreakVelocity") then
                        GetRoot(plr).BreakVelocity:Destroy()
                    end
                end)
            end)
        else
            _G.DraggingTarget = false
            
            if _G.DragLoop then
                task.cancel(_G.DragLoop)
                _G.DragLoop = nil
            end
            
            -- Parar animação e restaurar estado normal do personagem
            StopAnim()
            pcall(function()
                if plr.Character and plr.Character:FindFirstChild("Humanoid") then
                    plr.Character.Humanoid.PlatformStand = false
                end
                
                if GetRoot(plr):FindFirstChild("BreakVelocity") then
                    GetRoot(plr).BreakVelocity:Destroy()
                end
            end)
            
            WindUI:Notify({
                Title = "Drag",
                Content = "Stopped dragging the target.",
                Duration = 2
            })
            
            targetFeedback:SetDesc("Target: " .. TargetedPlayer.Name)
        end
    end
})

-- Botão Teleportar para o Alvo (sem toggle, ação única)
Tabs.TargetTab:Button({
    Title = "Teleport to Target",
    Desc = "Teleports to target (single action).",
    Callback = function()
        if not TargetedPlayer then
            WindUI:Notify({
                Title = "Error",
                Content = "No target selected.",
                Duration = 2
            })
            return
        end
        
        TeleportTO(0, 0, 0, TargetedPlayer, "safe")
        
        WindUI:Notify({
            Title = "Teleport",
            Content = "Teleporting for " .. TargetedPlayer.Name,
            Duration = 2
        })
        
        targetFeedback:SetDesc("Teleporting for " .. TargetedPlayer.Name)
    end
})

-- Corrigindo problemas de código duplicado no final do arquivo
-- Atualizar quando o alvo sair do jogo (já parece adequada, apenas garantindo limpeza correta)
Players.PlayerRemoving:Connect(function(player)
    pcall(function()
        if TargetedPlayer and player == TargetedPlayer then
            -- Limpar todos os loops ativos
            for _, loopName in ipairs({"ViewLoop", "FocusLoop", "BenxLoop", "HeadsitLoop", "StandLoop", "BackpackLoop", "DoggyLoop", "SugarLoop", "DragLoop"}) do
                if _G[loopName] then
                    task.cancel(_G[loopName])
                    _G[loopName] = nil
                end
            end
            
            -- Limpar estados
            _G.FlingActive = nil
            _G.ViewingTarget = nil
            _G.FocusingTarget = nil
            _G.BenxingTarget = nil
            _G.HeadsittingTarget = nil
            _G.StandingTarget = nil
            _G.BackpackingTarget = nil
            _G.DoggyingTarget = nil
            _G.SugaringTarget = nil
            _G.DraggingTarget = nil
            
            -- Parar animações e limpar efeitos
            StopAnim()
            pcall(function()
                if GetRoot(plr):FindFirstChild("BreakVelocity") then
                    GetRoot(plr).BreakVelocity:Destroy()
                end
                
                workspace.CurrentCamera.CameraSubject = plr.Character.Humanoid
            end)
            
            WindUI:Notify({
                Title = "Target Out",
                Content = player.Name .. " left the game.",
                Duration = 3
            })
        end
    end)
end)

-- Configurations
local SpamConfig = {
    SelectedPlayer = "Ninguém",
    IsSpamming = false,
    SpamDelay = 0.2,
    SpamMessage = "MoonOnTop"
}

local SpectateConfig = {
    SelectedPlayer = "Ninguém",
    IsSpectating = false,
    Camera = workspace.CurrentCamera
}

local AdminConfig = {
    GroupId = 7625597,
    AdminRank = 2,
    ModeratorRank = 2,
    AlertsEnabled = true
}

local TeleportLocations = {
    {Name = "🛡️ Safe Zone", Position = Vector3.new(-105.29137420654297, 642.4719848632812, 514.2374877929688)},
    {Name = "🏜️ Desert", Position = Vector3.new(-672.6334838867188, 642.568603515625, 1115.691162109375)},
    {Name = "🌋 Volcano", Position = Vector3.new(120.21180725097656, 685.631103515625, 1570.7666015625)},
    {Name = "🏖️ Beach", Position = Vector3.new(-29.751022338867188, 644.6039428710938, -70.5428695678711)},
    {Name = "🌫️ Cloud Arena", Position = Vector3.new(-1173.7010498046875, 1268.14404296875, 766.4228515625)}
}

local WalkSpeedConfig = {
    CurrentSpeed = 16,
    MinSpeed = 16,
    MaxSpeed = 500,
    Debounce = false
}

local ESPConfig = {
    FillColor = Color3.fromRGB(175, 25, 255),
    DepthMode = "AlwaysOnTop",
    FillTransparency = 0.5,
    OutlineColor = Color3.fromRGB(255, 255, 255),
    OutlineTransparency = 0,
    Enabled = false
}

-- Global variables
local isFarming = false
local autoEat = false
local dummyFarmActive = false
local dummyFarmConnection = nil
local clanName = ""
local ESPStorage = nil
local ESPConnections = {}
local _G = {
    attackAllNPCToggle = false,
    dummyFarm5kEnabled = false,
    killAura = false,
    huntPlayers = false,
    farmLowLevels = false
}

--[[
    FARM TAB
]]

-- Coin Farm function
local function coinFarmLoop()
    while isFarming and task.wait(0.1) do
        pcall(function()
            game:GetService("ReplicatedStorage").Events.CoinEvent:FireServer()
        end)
    end
end

-- Attack All NPCs function
local function attackAllNPCsLoop()
    while _G.attackAllNPCToggle and task.wait(0.01) do
        pcall(function()
            local npcsWithHealth = {}
            
            for _, npc in ipairs(workspace.NPC:GetDescendants()) do
                if npc:IsA("Humanoid") and npc.Health > 0 then
                    table.insert(npcsWithHealth, {
                        humanoid = npc,
                        health = npc.Health
                    })
                end
            end
            
            table.sort(npcsWithHealth, function(a, b)
                return a.health < b.health
            end)
            
            for _, npcData in ipairs(npcsWithHealth) do
                if _G.attackAllNPCToggle then
                    local args = {
                        [1] = npcData.humanoid,
                        [2] = 1
                    }
                    game:GetService("ReplicatedStorage").jdskhfsIIIllliiIIIdchgdIiIIIlIlIli:FireServer(unpack(args))
                end
            end
        end)
    end
end

-- Dummy Farm function
local function dummyFarmFunction()
    if dummyFarmConnection then
        dummyFarmConnection:Disconnect()
        dummyFarmConnection = nil
    end
    
    if dummyFarmActive then
        dummyFarmConnection = game:GetService("RunService").Heartbeat:Connect(function()
            pcall(function()
                local targetDummy = workspace.MAP.dummies:GetChildren()[1]
                if targetDummy and game.Players.LocalPlayer.Character then
                    local humanoid = targetDummy:FindFirstChild("Humanoid")
                    local rootPart = targetDummy:FindFirstChild("HumanoidRootPart")
                    local playerRoot = game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                    
                    if humanoid and rootPart and playerRoot then
                        playerRoot.CFrame = rootPart.CFrame * CFrame.new(0, 8, 0)
                        game:GetService("ReplicatedStorage").jdskhfsIIIllliiIIIdchgdIiIIIlIlIli:FireServer(humanoid, 1)
                    end
                end
            end)
        end)
    end
end

-- Dummy 5k Farm function
local function dummy5kFarmLoop()
    while _G.dummyFarm5kEnabled and task.wait() do
        pcall(function()
            local dummies = workspace.MAP["5k_dummies"]:GetChildren()
            local targetDummy = nil
            local shortestDistance = math.huge
            
            for _, dummy in pairs(dummies) do
                if dummy.Name == "Dummy2" then
                    if dummy:FindFirstChild("Humanoid") and dummy:FindFirstChild("HumanoidRootPart") then
                        local isOccupied = false
                        local dummyRoot = dummy.HumanoidRootPart
                        
                        for _, player in pairs(game.Players:GetPlayers()) do
                            if player.Character and player ~= game.Players.LocalPlayer then
                                local playerRoot = player.Character:FindFirstChild("HumanoidRootPart")
                                if playerRoot and (playerRoot.Position - dummyRoot.Position).Magnitude < 10 then
                                    isOccupied = true
                                    break
                                end
                            end
                        end
                        
                        if not isOccupied then
                            local distance = (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - dummyRoot.Position).Magnitude
                            if distance < shortestDistance then
                                shortestDistance = distance
                                targetDummy = dummy
                            end
                        end
                    end
                end
            end
            
            if targetDummy and game.Players.LocalPlayer.Character then
                local humanoid = targetDummy:FindFirstChild("Humanoid")
                local rootPart = targetDummy:FindFirstChild("HumanoidRootPart")
                local playerRoot = game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                
                if humanoid and rootPart and playerRoot then
                    playerRoot.CFrame = rootPart.CFrame * CFrame.new(0, 8, 0)
                    game:GetService("ReplicatedStorage").jdskhfsIIIllliiIIIdchgdIiIIIlIlIli:FireServer(humanoid, 1)
                end
            end
        end)
    end
end

--[[
    FARM TAB UI
]]

-- Coin Farm Toggle
Tabs.Farm:Toggle({
    Title = "💰 Coin Farm",
    Desc = "Automatically farms coins",
    Value = false,
    Callback = function(state)
        isFarming = state
        
        if isFarming then
            task.spawn(coinFarmLoop)
            WindUI:Notify({
                Title = "💰 Coin Farm Activated",
                Content = "Coin Farm has been activated.",
                Duration = 1
            })
        else
            WindUI:Notify({
                Title = "💰 Coin Farm Deactivated",
                Content = "Coin Farm has been deactivated.",
                Duration = 1
            })
        end
    end
})

-- Attack All Bosses Toggle
Tabs.Farm:Toggle({
    Title = "👹 Attack All Bosses",
    Desc = "Automatically attacks all bosses",
    Value = false,
    Callback = function(state)
        _G.attackAllNPCToggle = state
        
        if state then
            task.spawn(attackAllNPCsLoop)
        end
        
        WindUI:Notify({
            Title = "👹 Attack All Bosses",
            Content = state and "Auto attack on all bosses has been activated!" or "Auto attack on all bosses has been deactivated!",
            Duration = 1
        })
    end
})

-- Dummy Farm Toggle
Tabs.Farm:Toggle({
    Title = "🧍🏻 Dummy Farm",
    Desc = "Automatically farms dummies",
    Value = false,
    Callback = function(state)
        dummyFarmActive = state
        dummyFarmFunction()
        
        WindUI:Notify({
            Title = "🧍🏻 Dummy Farm " .. (state and "Activated" or "Deactivated"),
            Content = state and "Dummy Farm has been activated!" or "Dummy Farm has been deactivated!",
            Duration = 1
        })
    end
})

-- Dummy 5k Farm Toggle
Tabs.Farm:Toggle({
    Title = "🧍🏻 Dummy 5k Farm",
    Desc = "Automatically farms 5k dummies",
    Value = false,
    Callback = function(state)
        _G.dummyFarm5kEnabled = state
        
        if state then
            task.spawn(dummy5kFarmLoop)
        end
        
        WindUI:Notify({
            Title = "🧍🏻 Dummy 5k Farm " .. (state and "Activated" or "Deactivated"),
            Content = state and "Dummy 5k Farm has been activated!" or "Dummy 5k Farm has been deactivated!",
            Duration = 1
        })
    end
})

-- Free Radio Toggle
Tabs.Farm:Toggle({
    Title = "📻 Free Radio", 
    Desc = nil,
    Value = false,
    Callback = function(state)
        local gui = game.Players.LocalPlayer:FindFirstChild("PlayerGui")
        if gui and gui:FindFirstChild("DRadio_Gui") then
            gui.DRadio_Gui.Enabled = state
        end
        
        WindUI:Notify({
            Title = "📻 Free Radio",
            Content = state and "Free Radio has been activated!" or "Free Radio has been deactivated!",
            Duration = 1
        })
    end
})

-- Visual 13x Exp Toggle
Tabs.Farm:Toggle({
    Title = "🔍 Visual 13x Exp", 
    Desc = nil,
    Value = false,
    Callback = function(state)
        local gui = game.Players.LocalPlayer:FindFirstChild("PlayerGui")
        if gui and gui:FindFirstChild("LevelBar") and gui.LevelBar:FindFirstChild("gamepassText") then
            gui.LevelBar.gamepassText.Visible = state
            if state then
                gui.LevelBar.gamepassText.Text = "13x exp"
            end
        end
        
        WindUI:Notify({
            Title = "🔍 Visual 13x Exp",
            Content = state and "13x Exp has been activated!" or "13x Exp has been deactivated!",
            Duration = 1
        })
    end
})

--[[
    PVP TAB FUNCTIONS
]]

-- Auto Eat function
local function autoEatLoop()
    local VirtualInputManager = game:GetService("VirtualInputManager")
    
    while autoEat and task.wait(1) do
        pcall(function()
            -- Select food slot
            VirtualInputManager:SendKeyEvent(true, "One", false, game)
            task.wait(0.1)
            VirtualInputManager:SendKeyEvent(false, "One", false, game)
            task.wait(0.1)

            -- Click at screen center
            local screenCenterX = workspace.CurrentCamera.ViewportSize.X * 0.5
            local screenCenterY = workspace.CurrentCamera.ViewportSize.Y * 0.7
            
            VirtualInputManager:SendMouseButtonEvent(screenCenterX, screenCenterY, 0, true, game, 0)
            task.wait(0.05)
            VirtualInputManager:SendMouseButtonEvent(screenCenterX, screenCenterY, 0, false, game, 0)
        end)
    end
end

-- Kill Aura function
local function killAuraLoop()
    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local localPlayer = Players.LocalPlayer

    while _G.killAura and task.wait(0.01) do
        pcall(function()
            for _, player in ipairs(Players:GetPlayers()) do
                if player ~= localPlayer and player.Character then
                    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
                    if humanoid and humanoid.Health > 0 and not player.Character:FindFirstChild("SafeZoneShield") then
                        local args = {
                            [1] = humanoid,
                            [2] = 5
                        }
                        ReplicatedStorage.jdskhfsIIIllliiIIIdchgdIiIIIlIlIli:FireServer(unpack(args))
                    end
                end
            end
        end)
    end
end

-- Loop Kill All function
local function loopKillAllPlayers()
    local localPlayer = game.Players.LocalPlayer

    while _G.huntPlayers and task.wait() do
        pcall(function()
            for _, target in ipairs(game.Players:GetPlayers()) do
                if target ~= localPlayer and target.Character and target.Character:FindFirstChild("Humanoid") and 
                   target.Character.Humanoid.Health > 1 and not target.Character:FindFirstChild("SafeZoneShield") then

                    local targetRoot = target.Character:FindFirstChild("HumanoidRootPart")
                    local localRoot = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")

                    if targetRoot and localRoot then
                        if (localRoot.Position - targetRoot.Position).Magnitude > 10 then
                            localRoot.CFrame = targetRoot.CFrame
                        end

                        local startTime = tick()

                        while target.Character and target.Character:FindFirstChild("Humanoid") and 
                              target.Character.Humanoid.Health > 1 and _G.huntPlayers do

                            if tick() - startTime > 8 then
                                break
                            end

                            local carryArgs = {
                                [1] = target,
                                [2] = "request_accepted"
                            }
                            game:GetService("ReplicatedStorage").Events.CarryEvent:FireServer(unpack(carryArgs))

                            local attackArgs = {
                                [1] = target.Character.Humanoid,
                                [2] = 24
                            }
                            game:GetService("ReplicatedStorage").jdskhfsIIIllliiIIIdchgdIiIIIlIlIli:FireServer(unpack(attackArgs))

                            task.wait()
                        end
                    end
                end
            end
        end)
    end
end

-- Auto Kill Low Levels function
local function autoKillLowLevels()
    local lp = game.Players.LocalPlayer

    while _G.farmLowLevels and task.wait() do
        pcall(function()
            local best = nil
            for _, p in ipairs(game.Players:GetPlayers()) do
                if p ~= lp and p.Character and p:FindFirstChild("leaderstats") and 
                   p.leaderstats.Level.Value < lp.leaderstats.Level.Value and 
                   p.Character:FindFirstChild("HumanoidRootPart") and 
                   p.Character:FindFirstChild("Humanoid") and 
                   p.Character.Humanoid.Health > 1 and 
                   not p.Character:FindFirstChild("SafeZoneShield") and 
                   (not best or p.leaderstats.Level.Value < best.leaderstats.Level.Value) then 
                    best = p 
                end
            end

            if best and lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") then
                local lr, tr = lp.Character.HumanoidRootPart, best.Character.HumanoidRootPart
                if (lr.Position - tr.Position).Magnitude > 10 then 
                    lr.CFrame = tr.CFrame 
                end
                
                game:GetService("ReplicatedStorage").Events.CarryEvent:FireServer(best, "request_accepted")
                game:GetService("ReplicatedStorage").jdskhfsIIIllliiIIIdchgdIiIIIlIlIli:FireServer(best.Character.Humanoid, 24)
            end
        end)
    end
end

--[[
    PVP TAB UI
]]

-- Auto Eat Toggle
Tabs.PVP:Toggle({
    Title = "🐟 Auto Eat (PC)",
    Desc = "Enables or disables the Auto Eat function",
    Value = false,
    Callback = function(state)
        autoEat = state
        if autoEat then
            task.spawn(autoEatLoop)
        end
        
        WindUI:Notify({
            Title = "🐟 Auto Eat",
            Content = state and "Auto Eat has been activated." or "Auto Eat has been deactivated.",
            Duration = 1
        })
    end
})

-- Kill Aura Toggle
Tabs.PVP:Toggle({
    Title = "⚔️ Kill Aura",
    Desc = "Enables or disables the Kill Aura function",
    Value = false,
    Callback = function(state)
        _G.killAura = state
        if state then
            task.spawn(killAuraLoop)
        end
        
        WindUI:Notify({
            Title = "⚔️ Kill Aura " .. (state and "Activated" or "Deactivated"),
            Content = state and "Kill Aura is now active." or "Kill Aura is now inactive.",
            Duration = 1
        })
    end
})

-- Loop Kill All Toggle
Tabs.PVP:Toggle({
    Title = "🤯 Loop Kill All Players",
    Desc = "Automatically hunts and kills all players",
    Value = false,
    Callback = function(state)
        _G.huntPlayers = state
        if state then
            task.spawn(loopKillAllPlayers)
        end
        
        WindUI:Notify({
            Title = state and "🤯 Loop Kill Activated" or "🛑 Loop Kill Stopped",
            Content = state and "Now hunting all players!" or "Stopped hunting players.",
            Duration = 1
        })
    end
})

-- Auto Kill Low Levels Toggle
Tabs.PVP:Toggle({
    Title = "😎 Auto Kill Low Levels",
    Desc = "Automatically hunts players with a lower level than you",
    Value = false,
    Callback = function(state)
        _G.farmLowLevels = state
        if state then
            task.spawn(autoKillLowLevels)
        end
        
        WindUI:Notify({
            Title = state and "😎 Auto Kill Low Levels Activated" or "🛑 Auto Kill Low Levels Stopped",
            Content = state and "Hunting lower-level players!" or "Stopped hunting low-level players.",
            Duration = 1
        })
    end
})

-- Free Fireball Button
Tabs.PVP:Button({
    Title = "🔥 Free Fireball",
    Desc = "Click to get a fireball!",
    Callback = function()
        local tool = Instance.new("Tool")
        tool.Name = "Fireball"
        tool.RequiresHandle = false

        tool.Activated:Connect(function()
            local mouse = game.Players.LocalPlayer:GetMouse()
            local args = {
                [1] = mouse.Hit.p,
                [2] = "NewFireball"
            }
            game:GetService("ReplicatedStorage").SkillsInRS.RemoteEvent:FireServer(unpack(args))
        end)

        tool.Parent = game.Players.LocalPlayer.Backpack
        
        WindUI:Notify({
            Title = "🔥 Fireball Created",
            Content = "The Fireball has been added to your backpack!",
            Duration = 1
        })
    end
})

-- Free Lightningball Button
Tabs.PVP:Button({
    Title = "⚡ Free Lightningball",
    Desc = "Click to get a Lightning Ball!",
    Callback = function()
        local tool = Instance.new("Tool")
        tool.Name = "Lightning Ball"
        tool.RequiresHandle = false

        tool.Activated:Connect(function()
            local mouse = game.Players.LocalPlayer:GetMouse()
            for i = 1, 3 do
                local args = {
                    [1] = mouse.Hit.p,
                    [2] = "NewLightningball"
                }
                game:GetService("ReplicatedStorage").SkillsInRS.RemoteEvent:FireServer(unpack(args))
                task.wait(0.1)
            end
        end)

        tool.Parent = game.Players.LocalPlayer.Backpack
        
        WindUI:Notify({
            Title = "⚡ Lightningball Created",
            Content = "The Lightningball has been added to your backpack!",
            Duration = 1
        })
    end
})

--[[
    PLAYER TELEPORT SYSTEM
]]

-- Player List Functions
local function getPlayers()
    local players = {"Ninguém"} -- Always start with "Ninguém" as first option
    for _, player in ipairs(game:GetService("Players"):GetPlayers()) do
        if player ~= game.Players.LocalPlayer then
            table.insert(players, player.Name)
        end
    end
    return players
end

local function updateTeleportDropdown()
    local players = getPlayers()
    
    if TeleportDropdown then
        local currentSelection = TeleportConfig.SelectedPlayer
        local selectionExists = false
        
        for _, player in ipairs(players) do
            if player == currentSelection then
                selectionExists = true
                break
            end
        end
        
        TeleportDropdown:Refresh(players)
        
        if not selectionExists or currentSelection == nil then
            TeleportDropdown:Select("Ninguém")
            TeleportConfig.SelectedPlayer = "Ninguém"
        else
            TeleportDropdown:Select(currentSelection)
        end
    end
end

local TeleportConfig = {
    SelectedPlayer = "Ninguém"
}

-- Teleport Dropdown
TeleportDropdown = Tabs.PVP:Dropdown({
    Title = "🙋🏻 Teleport to Player",
    Desc = "Select a player to teleport to",
    Values = getPlayers(),
    Multi = false,
    Default = "Ninguém",
    Callback = function(selectedPlayer)
        TeleportConfig.SelectedPlayer = selectedPlayer
        
        if selectedPlayer == "Ninguém" then 
            WindUI:Notify({
                Title = "Teleport",
                Content = "No player selected",
                Duration = 1
            })
            return 
        end
        
        local localPlayer = game:GetService("Players").LocalPlayer
        local targetPlayer = game:GetService("Players"):FindFirstChild(selectedPlayer)

        if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
            if localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
                localPlayer.Character:SetPrimaryPartCFrame(targetPlayer.Character.HumanoidRootPart.CFrame)
                
                WindUI:Notify({
                    Title = "🙋🏻 Teleport Successful",
                    Content = "You have successfully teleported to " .. targetPlayer.Name .. "!",
                    Duration = 1
                })
            end
        else
            WindUI:Notify({
                Title = "Error",
                Content = "Player not found or invalid target!",
                Duration = 1
            })
        end
    end
})

-- Clan Name Input
Tabs.PVP:Input({
    Title = "🏛️ Force Join Clan",
    Desc = "Enter the clan name to join",
    Default = "",
    Placeholder = "Enter clan name...",
    Callback = function(Value)
        clanName = Value
    end
})

-- Join Clan Button
Tabs.PVP:Button({
    Title = "🏛️ Join Clan",
    Desc = "Force to join the entered clan",
    Callback = function()
        if clanName == "" then
            WindUI:Notify({
                Title = "Error",
                Content = "Please enter a valid clan name!",
                Duration = 1
            })
            return
        end

        local args = {
            [1] = {
                ["teamIcon"] = "",
                ["action"] = "accepted",
                ["teamName"] = clanName
            }
        }

        pcall(function()
            game:GetService("ReplicatedStorage").invitationEvent:FireServer(unpack(args))
        end)

        WindUI:Notify({
            Title = "🏛️ Join Clan",
            Content = "Forced to join '" .. clanName .. "' has been successful!",
            Duration = 1
        })
    end
})

-- ESP System
local function InitializeESPStorage()
    if not ESPStorage then
        ESPStorage = Instance.new("Folder")
        ESPStorage.Name = "ESP_Storage"
        ESPStorage.Parent = game:GetService("CoreGui")
    end
end

local function CreateESP(player)
    if not ESPStorage or not ESPConfig.Enabled then return end
    
    local highlight = Instance.new("Highlight")
    highlight.Name = player.Name
    highlight.FillColor = ESPConfig.FillColor
    highlight.DepthMode = ESPConfig.DepthMode
    highlight.FillTransparency = ESPConfig.FillTransparency
    highlight.OutlineColor = ESPConfig.OutlineColor
    highlight.OutlineTransparency = ESPConfig.OutlineTransparency
    highlight.Parent = ESPStorage

    if player.Character then
        highlight.Adornee = player.Character
    end

    ESPConnections[player] = player.CharacterAdded:Connect(function(character)
        highlight.Adornee = character
    end)
end

local function RemoveESP(player)
    if ESPStorage then
        local esp = ESPStorage:FindFirstChild(player.Name)
        if esp then
            esp:Destroy()
        end
    end
    
    if ESPConnections[player] then
        ESPConnections[player]:Disconnect()
        ESPConnections[player] = nil
    end
end

local function ToggleESP(state)
    ESPConfig.Enabled = state
    
    if state then
        InitializeESPStorage()
        for _, player in ipairs(game:GetService("Players"):GetPlayers()) do
            if player ~= game.Players.LocalPlayer then
                CreateESP(player)
            end
        end
    else
        for player, _ in pairs(ESPConnections) do
            RemoveESP(player)
        end
        
        if ESPStorage then
            ESPStorage:Destroy()
            ESPStorage = nil
        end
    end
    
    WindUI:Notify({
        Title = "👁️ ESP Players",
        Content = state and "ESP Activated!" or "ESP Deactivated!",
        Duration = 1
    })
end

Tabs.PVP:Toggle({
    Title = "👁️ ESP Players",
    Desc = "Toggle to activate or deactivate ESP for players",
    Value = false,
    Callback = function(state)
        ToggleESP(state)
    end
})

-- Walk Speed Slider
local function updateWalkSpeed(speed)
    local character = game.Players.LocalPlayer.Character
    if character and character:FindFirstChildOfClass("Humanoid") then
        character.Humanoid.WalkSpeed = speed
    end
end

local function delayedNotification()
    if WalkSpeedConfig.Debounce then return end
    WalkSpeedConfig.Debounce = true
    
    task.wait(1) -- Wait 1 second after last slider movement
    
    WindUI:Notify({
        Title = "🚀 Speed Adjustment",
        Content = "Your walk speed has been set to " .. WalkSpeedConfig.CurrentSpeed .. "!",
        Duration = 1
    })
    
    WalkSpeedConfig.Debounce = false
end

Tabs.PVP:Slider({
    Title = "🚀 Walk Speed",
    Desc = "Adjust your character's movement speed",
    Value = {
        Min = WalkSpeedConfig.MinSpeed,
        Max = WalkSpeedConfig.MaxSpeed,
        Default = WalkSpeedConfig.CurrentSpeed
    },
    Callback = function(value)
        WalkSpeedConfig.CurrentSpeed = value
        updateWalkSpeed(value)
        task.spawn(delayedNotification)
    end
})

-- Character connection to maintain speed on respawn
game:GetService("Players").LocalPlayer.CharacterAdded:Connect(function(character)
    if WalkSpeedConfig.CurrentSpeed > WalkSpeedConfig.MinSpeed then
        character:WaitForChild("Humanoid")
        updateWalkSpeed(WalkSpeedConfig.CurrentSpeed)
    end
end)

-- Teleport Locations
local function teleportTo(location)
    local character = game.Players.LocalPlayer.Character
    if character and character:FindFirstChild("HumanoidRootPart") then
        character.HumanoidRootPart.CFrame = CFrame.new(location.Position)
        
        WindUI:Notify({
            Title = location.Name,
            Content = "You have been teleported successfully!",
            Duration = 3
        })
    else
        WindUI:Notify({
            Title = "Error",
            Content = "Character not found or invalid!",
            Duration = 3
        })
    end
end

-- Create teleport buttons
for _, location in ipairs(TeleportLocations) do
    Tabs.Teleport:Button({
        Title = location.Name,
        Desc = "Teleport to " .. location.Name:gsub("%p", ""),
        Callback = function()
            teleportTo(location)
        end
    })
end

-- Admin Alerts
local function checkAdminStatus(player)
    local success, rank = pcall(function()
        return player:GetRankInGroup(AdminConfig.GroupId)
    end)
    
    if not success then return false, false end
    
    local isAdmin = rank >= AdminConfig.AdminRank
    local isModerator = not isAdmin and rank >= AdminConfig.ModeratorRank
    
    return isAdmin, isModerator
end

local function playerAdded(player)
    if not AdminConfig.AlertsEnabled then return end
    
    local isAdmin, isModerator = checkAdminStatus(player)
    
    if isAdmin or isModerator then
        local role = isAdmin and "Administrator" or "Moderator"
        
        WindUI:Notify({
            Title = "⚠️ Staff Join Alert",
            Content = player.Name .. " (" .. role .. ") has joined the game",
            Duration = 1
        })
    end
end

--[[
    MISC TAB - ADMIN ALERTS
]]

Tabs.Misc:Toggle({
    Title = "⚠️ Staff Join Alerts",
    Desc = "Get notifications when staff members join",
    Value = true,
    Callback = function(state)
        AdminConfig.AlertsEnabled = state
        WindUI:Notify({
            Title = "Staff Alerts",
            Content = state and "Staff join alerts enabled" or "Staff join alerts disabled",
            Duration = 1
        })
    end
})

-- Spectate System
local function updateSpectateDropdown()
    local players = getPlayers()
    
    if SpectateDropdown then
        local currentSelection = SpectateConfig.SelectedPlayer
        local selectionExists = false
        
        for _, player in ipairs(players) do
            if player == currentSelection then
                selectionExists = true
                break
            end
        end
        
        SpectateDropdown:Refresh(players)
        
        if not selectionExists or currentSelection == nil then
            SpectateDropdown:Select("Ninguém")
            SpectateConfig.SelectedPlayer = "Ninguém"
        else
            SpectateDropdown:Select(currentSelection)
        end
    end
end

local function startSpectating()
    if not SpectateConfig.SelectedPlayer or SpectateConfig.SelectedPlayer == "Ninguém" then
        WindUI:Notify({
            Title = "Error",
            Content = "No player selected to spectate!",
            Duration = 3
        })
        return
    end

    local target = game:GetService("Players"):FindFirstChild(SpectateConfig.SelectedPlayer)
    if target and target.Character then
        local humanoidRootPart = target.Character:FindFirstChild("HumanoidRootPart")
        if humanoidRootPart then
            SpectateConfig.IsSpectating = true
            SpectateConfig.Camera.CameraSubject = humanoidRootPart
            
            WindUI:Notify({
                Title = "🧿 Spectating",
                Content = "Now spectating " .. target.Name,
                Duration = 3
            })

            target.CharacterAdded:Connect(function(character)
                if SpectateConfig.IsSpectating then
                    character:WaitForChild("HumanoidRootPart")
                    SpectateConfig.Camera.CameraSubject = character.HumanoidRootPart
                end
            end)
        end
    else
        WindUI:Notify({
            Title = "Error",
            Content = "Player not found or invalid target!",
            Duration = 3
        })
    end
end

local function stopSpectating()
    SpectateConfig.IsSpectating = false
    local character = game.Players.LocalPlayer.Character
    if character then
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            SpectateConfig.Camera.CameraSubject = humanoid
        end
    end
    
    WindUI:Notify({
        Title = "🧿 Spectating Stopped",
        Content = "No longer spectating",
        Duration = 3
    })
    
    if SpectateDropdown then
        SpectateDropdown:Select("Ninguém")
        SpectateConfig.SelectedPlayer = "Ninguém"
    end
end

-- Spectate Dropdown
SpectateDropdown = Tabs.Misc:Dropdown({
    Title = "🧿 Spectate Player",
    Desc = "Select a player to spectate",
    Values = getPlayers(),
    Multi = false,
    Default = "Ninguém",
    Callback = function(selected)
        SpectateConfig.SelectedPlayer = selected
        if selected ~= "Ninguém" then
            WindUI:Notify({
                Title = "Player Selected",
                Content = "Ready to spectate: " .. selected,
                Duration = 2
            })
        end
    end
})

-- Spectate Buttons
Tabs.Misc:Button({
    Title = "▶️ Start Spectating",
    Desc = "Begin spectating the selected player",
    Callback = startSpectating
})

Tabs.Misc:Button({
    Title = "⏹️ Stop Spectating",
    Desc = "Stop spectating and return to your character",
    Callback = stopSpectating
})

-- Spam System
local function updateSpamDropdown()
    local players = getPlayers()
    if SpamDropdown then
        SpamDropdown:Refresh(players)
        if not table.find(players, SpamConfig.SelectedPlayer) then
            SpamConfig.SelectedPlayer = "Ninguém"
            SpamDropdown:Select("Ninguém")
        end
    end
end

local function startSpamming()
    if SpamConfig.SelectedPlayer == "Ninguém" then
        WindUI:Notify({
            Title = "Error",
            Content = "No player selected to spam!",
            Duration = 1
        })
        return
    end

    SpamConfig.IsSpamming = true
    local target = game:GetService("Players"):FindFirstChild(SpamConfig.SelectedPlayer)
    
    if not target then
        WindUI:Notify({
            Title = "Error",
            Content = "Player not found!",
            Duration = 1
        })
        SpamConfig.IsSpamming = false
        return
    end

    WindUI:Notify({
        Title = "🗣️ Spamming Started",
        Content = "Now spamming " .. target.Name,
        Duration = 1
    })

    while SpamConfig.IsSpamming and task.wait(SpamConfig.SpamDelay) do
        if not target or not game:GetService("Players"):FindFirstChild(SpamConfig.SelectedPlayer) then
            SpamConfig.IsSpamming = false
            SpamConfig.SelectedPlayer = "Ninguém"
            updateSpamDropdown()
            WindUI:Notify({
                Title = "Error",
                Content = "Player left the game!",
                Duration = 1
            })
            break
        end

        local args = {
            [1] = {
                ["toolname"] = "RoseB",
                ["oplr"] = target,
                ["action"] = "give",
                ["gift"] = SpamConfig.SpamMessage,
            }
        }
        
        pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("GiveEvent"):FireServer(unpack(args))
        end)
    end
end

local function stopSpamming()
    SpamConfig.IsSpamming = false
    WindUI:Notify({
        Title = "🗣️ Spamming Stopped",
        Content = "Stopped spamming " .. (SpamConfig.SelectedPlayer ~= "Ninguém" and SpamConfig.SelectedPlayer or ""),
        Duration = 1
    })
end

-- Spam Dropdown
SpamDropdown = Tabs.Misc:Dropdown({
    Title = "🗣️ Spam Target Player",
    Desc = "Select a player to spam",
    Values = getPlayers(),
    Multi = false,
    Default = "Ninguém",
    Callback = function(selected)
        SpamConfig.SelectedPlayer = selected
        if selected ~= "Ninguém" then
            WindUI:Notify({
                Title = "Player Selected",
                Content = "Ready to spam: " .. selected,
                Duration = 1
            })
        end
    end
})

-- Spam Buttons
Tabs.Misc:Button({
    Title = "▶️ Start Spamming",
    Desc = "Begin spamming the selected player",
    Callback = startSpamming
})

Tabs.Misc:Button({
    Title = "⏹️ Stop Spamming",
    Desc = "Stop spamming the selected player",
    Callback = stopSpamming
})

-- Misc Buttons
Tabs.Misc:Button({
    Title = "🗣️ Unban Voice Chat",
    Desc = "Click to remove your voice chat ban",
    Callback = function()
        local success, err = pcall(function()
            game:GetService("VoiceChatService"):JoinVoiceChat()
        end)
        
        if success then
            WindUI:Notify({
                Title = "🗣️ Voice Chat Unbanned",
                Content = "Your voice chat has been unbanned!",
                Duration = 1
            })
        else
            WindUI:Notify({
                Title = "Error",
                Content = "Failed to unban voice chat: " .. tostring(err),
                Duration = 1
            })
        end
    end
})

Tabs.Misc:Button({
    Title = "☠️ Fling",
    Desc = "Carry someone, enable this, then release to fling them",
    Callback = function()
        local success, err = pcall(function()
            loadstring(game:HttpGet("https://raw.githubusercontent.com/nick0022/walkflinng/refs/heads/main/README.md", true))()
        end)
        
        if success then
            WindUI:Notify({
                Title = "☠️ Fling Activated",
                Content = "The fling script has been executed successfully!",
                Duration = 1
            })
        else
            WindUI:Notify({
                Title = "Error",
                Content = "Failed to load fling script: " .. tostring(err),
                Duration = 1
            })
        end
    end
})

Tabs.Misc:Button({
    Title = "🕳️ Void Player",
    Desc = "Carry a player, activate this, then drop them into the void",
    Callback = function()
        local player = game.Players.LocalPlayer
        local character = player.Character
        
        if not character or not character.PrimaryPart then
            WindUI:Notify({
                Title = "Error",
                Content = "Character not found or invalid!",
                Duration = 1
            })
            return
        end

        local originalPosition = character.PrimaryPart.Position
        local voidPosition = originalPosition - Vector3.new(0, 500, 0)

        WindUI:Notify({
            Title = "🕳️ Void Player",
            Content = "Preparing void teleport...",
            Duration = 1
        })

        character:SetPrimaryPartCFrame(CFrame.new(voidPosition))

        WindUI:Notify({
            Title = "🕳️ Void Player",
            Content = "Player sent to void! Releasing in 3 seconds...",
            Duration = 3
        })

        task.wait(3)
        
        if character and character.PrimaryPart then
            character:SetPrimaryPartCFrame(CFrame.new(originalPosition))
            WindUI:Notify({
                Title = "🕳️ Void Player",
                Content = "Player returned from void!",
                Duration = 1
            })
        else
            WindUI:Notify({
                Title = "Error",
                Content = "Character became invalid during process!",
                Duration = 1
            })
        end
    end
})

-- Scripts Tab
Tabs.Scripts:Button({
    Title = "📄 Infinity Yield",
    Desc = "Execute the Infinity Yield script",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source"))()
        WindUI:Notify({
            Title = "📄 Infinity Yield",
            Content = "The Infinity Yield script has been executed successfully!",
            Duration = 1
        })
    end
})

Tabs.Scripts:Button({
    Title = "📄 Moon AntiAfk",
    Desc = "Execute the Moon AntiAfk script",
    Callback = function()
        loadstring(game:HttpGet('https://raw.githubusercontent.com/rodri0022/afkmoon/refs/heads/main/README.md', true))()
        WindUI:Notify({
            Title = "📄 Moon AntiAfk",
            Content = "The Moon AntiAfk script has been executed!",
            Duration = 1
        })
    end
})

Tabs.Scripts:Button({
    Title = "📄 Moon AntiLag",
    Desc = "Execute the Moon AntiLag script",
    Callback = function()
        loadstring(game:HttpGet('https://raw.githubusercontent.com/nick0022/antilag/refs/heads/main/README.md', true))()
        WindUI:Notify({
            Title = "📄 Moon AntiLag",
            Content = "The Moon AntiLag script has been executed!",
            Duration = 1
        })
    end
})

Tabs.Scripts:Button({
    Title = "📄 FE R15 Emotes and Animation",
    Desc = "Execute the FE R15 Emotes and Animation script",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/BeemTZy/Motiona/refs/heads/main/source.lua"))()
        WindUI:Notify({
            Title = "📄 FE R15 Emotes and Animation",
            Content = "The FE R15 Emotes and Animation script has been executed!",
            Duration = 1
        })
    end
})

Tabs.Scripts:Button({
    Title = "📄 Moon FE Emotes",
    Desc = "Execute the Moon Emotes script",
    Callback = function()
        loadstring(game:HttpGet('https://raw.githubusercontent.com/rodri0022/freeanimmoon/refs/heads/main/README.md', true))()
        WindUI:Notify({
            Title = "📄 Moon Emotes",
            Content = "The Moon Emotes script has been executed!",
            Duration = 1
        })
    end
})

Tabs.Scripts:Button({
    Title = "📄 Moon Troll",
    Desc = "Execute the Moon Troll script",
    Callback = function()
        loadstring(game:HttpGet('https://raw.githubusercontent.com/nick0022/trollscript/refs/heads/main/README.md'))()
        WindUI:Notify({
            Title = "📄 Moon Troll",
            Content = "The Moon Troll script has been executed!",
            Duration = 1
        })
    end
})

Tabs.Scripts:Button({
    Title = "📄 Sirius",
    Desc = "Execute the Sirius script",
    Callback = function()
        loadstring(game:HttpGet('https://sirius.menu/sirius'))()
        WindUI:Notify({
            Title = "📄 Sirius",
            Content = "The Sirius script has been executed!",
            Duration = 1
        })
    end
})

Tabs.Scripts:Button({
    Title = "📄 Keyboard",
    Desc = "Execute the Keyboard script",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/GGH52lan/GGH52lan/main/keyboard.txt"))()
        WindUI:Notify({
            Title = "📄 Keyboard",
            Content = "The Keyboard script has been executed!",
            Duration = 1
        })
    end
})

Tabs.Scripts:Button({
    Title = "📄 Shader",
    Desc = "Script para deixar seu jogo bonito.",
    Callback = function()
        loadstring(game:HttpGet('https://raw.githubusercontent.com/randomstring0/pshade-ultimate/refs/heads/main/src/cd.lua'))()
        WindUI:Notify({
            Title = "📄 shader",
            Content = "o script shader foi executado!",
            Duration = 1
        })
    end
})

Tabs.Scripts:Button({
    Title = "📄 ChatBypass",
    Desc = "Script para deixar você mandar o que quiser no chat. Key: heypew",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/randomizedcomponent/UC/refs/heads/main/3307468c285f4fe535fb5d87b4b053e6.lua"))()
        WindUI:Notify({
            Title = "📄 Chatbypass",
            Content = "o script Chatbypass foi executado!",
            Duration = 1
        })
    end
})

Tabs.Scripts:Button({
    Title = "📄 SystemBroken",
    Desc = "Script parecido com esse",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/H20CalibreYT/SystemBroken/main/script"))()
        WindUI:Notify({
            Title = "📄 systembroken",
            Content = "o script systembroken foi executado!",
            Duration = 1
        })
    end
})

-- Skins Tab
-- Christmas Skins Button
Tabs.Skins:Button({
    Title = "🎅🏻 Christmas Skins",
    Desc = "Unlock all Christmas skins",
    Callback = function()
        local skins = {"XM24Fr", "XM24Fr", "XM24Bear", "XM24Eag", "XM24Br", "XM24Cr", "XM24Sq"}
        
        for _, skin in pairs(skins) do
            game:GetService("ReplicatedStorage").Events.SkinClickEvent:FireServer(skin, "v2")
            task.wait(0.1)
        end

        WindUI:Notify({
            Title = "🎅🏻 Christmas Skins Unlocked",
            Content = "All Christmas skins have been successfully unlocked!",
            Duration = 3
        })
    end
})

-- Pig Skins Button
Tabs.Skins:Button({
    Title = "🐷 Pig Skins",
    Desc = "Unlock all Pig skins",
    Callback = function()
        local skins = {"PIG1", "PIG2", "PIG3", "PIG4", "PIG5", "PIG6", "PIG7", "PIG8"}
        
        for _, skin in pairs(skins) do
            game:GetService("ReplicatedStorage").Events.SkinClickEvent:FireServer(skin, "v2")
            task.wait(0.1)
        end

        WindUI:Notify({
            Title = "🐷 Pig Skins Unlocked",
            Content = "All Pig skins have been successfully unlocked!",
            Duration = 3
        })
    end
})

-- Serviços do Roblox
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

-- Defina as localizações para facilitar a leitura
local localizacaoA = Vector3.new(-127.946053, 642.647949, 429.429596)
local localizacaoB = Vector3.new(-137.940262, 642.648254, 434.050598)

-- Função para teleportar o jogador local com espera de 2 segundos ANTES
local function TeleportarJogador(posicao)
    -- Garante que só roda no cliente
    if not RunService:IsClient() then return end 
    
    local player = Players.LocalPlayer
    if not player then return end 
    
    local character = player.Character or player.CharacterAdded:Wait()
    if not character then return end 

    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then 
        warn("HumanoidRootPart não encontrado para teleporte.")
        return 
    end

    -- >>> Adiciona a espera de 2 segundos ANTES de teleportar <<<
    print("Aguardando 2 segundos antes do teleporte para: " .. tostring(posicao))
    task.wait(2) -- Espera por 2 segundos
    
    -- Realiza o teleporte
    print("Teleportando agora...")
    humanoidRootPart.CFrame = CFrame.new(posicao)
    
    -- Pequena espera APÓS o teleporte (pode ser útil para estabilização)
    task.wait(0.1) 
end

-- Função para disparar o evento remoto (sem alterações na espera interna)
local function DispararEventoPuzzle(numeroPuzzle)
    if not RunService:IsClient() then return end 

    local easterEventFolder = ReplicatedStorage:WaitForChild("Easter2025", 9e9) 
    if not easterEventFolder then
        warn("Pasta 'Easter2025' não encontrada em ReplicatedStorage.")
        return
    end
    
    local remoteEvent = easterEventFolder:WaitForChild("RemoteEvent", 9e9) 
    if not remoteEvent then
        warn("RemoteEvent 'RemoteEvent' não encontrado dentro de 'Easter2025'.")
        return
    end

    local args = {
        [1] = {
            ["action"] = "pick_up";
            ["puzzle_name"] = "PUZ" .. tostring(numeroPuzzle); 
        };
    }

    print("Disparando evento para: PUZ" .. tostring(numeroPuzzle))
    remoteEvent:FireServer(unpack(args))
    task.wait(0.1) -- Pequena espera após disparar o evento
end

-- Cria o botão na UI
Tabs.Skins:Button({
    Title = "Easter Event Skins", -- Nome atualizado
    Desc = "Unlock all the skins for the 2025 Easter event", -- Descrição atualizada
    Callback = function()
        print("Botão clicado! Iniciando sequência com esperas de 2 segundos antes de cada teleporte...")

        -- Loop de 1 a 25
        for i = 1, 25 do
            print("--- Iniciando ciclo " .. i .. " ---")

            -- 1. Teleportar para Localização A 
            --    (A função TeleportarJogador agora contém a espera de 2s)
            TeleportarJogador(localizacaoA) 

            -- 2. Disparar Evento Remoto PUZi
            DispararEventoPuzzle(i) 

            -- 3. Teleportar para Localização B
            --    (A função TeleportarJogador agora contém a espera de 2s)
            TeleportarJogador(localizacaoB)

            -- 4. Teleportar de volta para Localização A
            --    (A função TeleportarJogador agora contém a espera de 2s)
            TeleportarJogador(localizacaoA)

            print("--- Ciclo " .. i .. " concluído ---")
            -- A pausa de 0.5s entre os ciclos completos foi removida, 
            -- pois os waits de 2s antes de cada teleporte já adicionam bastante tempo.
            -- Se ainda quiser uma pausa extra aqui, descomente a linha abaixo:
            -- task.wait(0.5) 
        end

        print("Sequência com esperas completa!")
    end,
})

print("Easter event skins")

Tabs.Skins:Button({
    Title = "⚔️ Secret Weapon",
    Desc = "Unlock a secret sword skin",
    Callback = function()
        local args = {
            [1] = "SSSSSSS2";
        }
        
        game:GetService("ReplicatedStorage"):WaitForChild("Events", 9e9):WaitForChild("WeaponEvent", 9e9):FireServer(unpack(args))

        WindUI:Notify({
            Title = "⚔️ Secret Weapon Unlocked",
            Content = "Secret sword skin has been successfully unlocked!",
            Duration = 3
        })
    end
})

Tabs.Skins:Button({
    Title = "⚔️ Secret Weapon2",
    Desc = "Unlock a secret sword skin",
    Callback = function()
        local args = {
            [1] = "SSSSSSS4";
        }
        
        game:GetService("ReplicatedStorage"):WaitForChild("Events", 9e9):WaitForChild("WeaponEvent", 9e9):FireServer(unpack(args))

        WindUI:Notify({
            Title = "⚔️ Secret Weapon2 Unlocked",
            Content = "Secret sword skin has been successfully unlocked!",
            Duration = 3
        })
    end
})

Tabs.Skins:Button({
    Title = "⚔️ Secret Weapon3",
    Desc = "Unlock a secret sword skin",
    Callback = function()
        local args = {
            [1] = "SSSS2";
        }
        
        game:GetService("ReplicatedStorage"):WaitForChild("Events", 9e9):WaitForChild("WeaponEvent", 9e9):FireServer(unpack(args))

        WindUI:Notify({
            Title = "⚔️ Secret Weapon3 Unlocked",
            Content = "Secret sword skin has been successfully unlocked!",
            Duration = 3
        })
    end
})

Tabs.Skins:Button({
    Title = "⚔️ Secret Weapon4",
    Desc = "Unlock a secret sword skin",
    Callback = function()
        local args = {
            [1] = "SSSS1";
        }
        
        game:GetService("ReplicatedStorage"):WaitForChild("Events", 9e9):WaitForChild("WeaponEvent", 9e9):FireServer(unpack(args))

        WindUI:Notify({
            Title = "⚔️ Secret Weapon4 Unlocked",
            Content = "Secret sword skin has been successfully unlocked!",
            Duration = 3
        })
    end
})

--[[
    SETTINGS TAB
]]

-- Update Lists Button
local function manualUpdateAllDropdowns()
    updateTeleportDropdown()
    updateSpectateDropdown()
    updateSpamDropdown()
    
    WindUI:Notify({
        Title = "🔄 Lists Updated",
        Content = "All player lists have been updated!",
        Duration = 1
    })
end

Tabs.Settings:Button({
    Title = "🔄 Update Player Lists",
    Desc = "Click to manually update all player lists",
    Callback = manualUpdateAllDropdowns
})

Tabs.Settings:Button({
    Title = "🔃 Rejoin Game",
    Desc = "Rejoin the current game session",
    Callback = function()
        game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, game.JobId)
        WindUI:Notify({
            Title = "Rejoining Game",
            Content = "Attempting to rejoin the current session...",
            Duration = 1
        })
    end
})

Tabs.Settings:Section({ Title = "Window Configuration" })

local themeValues = {}
for name, _ in pairs(WindUI:GetThemes()) do
    table.insert(themeValues, name)
end

local themeDropdown = Tabs.Settings:Dropdown({
    Title = "Select Theme",
    Desc = "Change the UI theme",
    Values = themeValues,
    Multi = false,
    Default = WindUI:GetCurrentTheme(),
    Callback = function(theme)
        WindUI:SetTheme(theme)
    end
})

local transparencyToggle = Tabs.Settings:Toggle({
    Title = "Window Transparency",
    Desc = "Toggle window transparency effect",
    Value = WindUI:GetTransparency(),
    Callback = function(state)
        Window:ToggleTransparency(state)
    end
})

Tabs.Settings:Section({ Title = "Save/Load Configuration" })

local configName = ""

Tabs.Settings:Input({
    Title = "Configuration Name",
    Desc = "Enter a name for your config",
    Default = "",
    PlaceholderText = "MyConfig",
    Callback = function(text)
        configName = text
    end
})

local configFiles = listfiles("MoonHUB") or {}
local configDropdown = Tabs.Settings:Dropdown({
    Title = "Saved Configurations",
    Desc = "Select a configuration to load",
    Values = configFiles,
    Multi = false,
    Default = nil,
    Callback = function(selected)
        configName = selected
    end
})

Tabs.Settings:Button({
    Title = "💾 Save Configuration",
    Desc = "Save current settings to file",
    Callback = function()
        if configName ~= "" then
            -- Criar a pasta MoonHUB se não existir
            if not isfolder("MoonHUB") then
                makefolder("MoonHUB")
            end
            
            local configData = {
                Theme = WindUI:GetCurrentTheme(),
                Transparency = WindUI:GetTransparency(),
                WalkSpeed = WalkSpeedConfig.CurrentSpeed,
                ESPEnabled = ESPConfig.Enabled,
                Keybind = tostring(currentKeybind) -- Alterado para usar currentKeybind
            }
            
            local success, err = pcall(function()
                writefile("MoonHUB/"..configName..".json", game:GetService("HttpService"):JSONEncode(configData))
            end)
            
            if success then
                WindUI:Notify({
                    Title = "Configuration Saved",
                    Content = "Settings saved as: "..configName,
                    Duration = 3
                })
                -- Atualizar a lista de configurações
                configFiles = listfiles("MoonHUB") or {}
                configDropdown:Refresh(configFiles)
            else
                WindUI:Notify({
                    Title = "Error",
                    Content = "Failed to save config: "..tostring(err),
                    Duration = 3
                })
            end
        else
            WindUI:Notify({
                Title = "Error",
                Content = "Please enter a configuration name!",
                Duration = 2
            })
        end
    end
})

Tabs.Settings:Button({
    Title = "📂 Load Configuration",
    Desc = "Load settings from file",
    Callback = function()
        if configName ~= "" and isfile("MoonHUB/"..configName..".json") then
            local success, configData = pcall(function()
                return game:GetService("HttpService"):JSONDecode(readfile("MoonHUB/"..configName..".json"))
            end)
            
            if success and configData then
                -- Aplicar configurações carregadas
                if configData.Theme then
                    WindUI:SetTheme(configData.Theme)
                    themeDropdown:Select(configData.Theme)
                end
                
                if configData.Transparency ~= nil then
                    Window:ToggleTransparency(configData.Transparency)
                    transparencyToggle:SetValue(configData.Transparency)
                end
                
                if configData.WalkSpeed then
                    WalkSpeedConfig.CurrentSpeed = configData.WalkSpeed
                    updateWalkSpeed(configData.WalkSpeed)
                end
                
                if configData.ESPEnabled ~= nil then
                    ToggleESP(configData.ESPEnabled)
                end
                
                if configData.Keybind then
                    currentKeybind = Enum.KeyCode[configData.Keybind]
                    Window:SetToggleKey(currentKeybind)
                    setupKeybindListener()
                end
                
                WindUI:Notify({
                    Title = "Configuration Loaded",
                    Content = "Settings loaded from: "..configName,
                    Duration = 3
                })
            else
                WindUI:Notify({
                    Title = "Error",
                    Content = "Failed to load config!",
                    Duration = 3
                })
            end
        else
            WindUI:Notify({
                Title = "Error",
                Content = "Config file not found!",
                Duration = 2
            })
        end
    end
})

Tabs.Settings:Button({
    Title = "🔄 Refresh Config List",
    Desc = "Update the list of saved configurations",
    Callback = function()
        configFiles = listfiles("MoonHUB") or {}
        configDropdown:Refresh(configFiles)
        WindUI:Notify({
            Title = "Config List Updated",
            Content = "Configuration list has been refreshed",
            Duration = 1
        })
    end
})

-- Corrigindo o sistema de dropdowns para evitar erros de nil
local function safeUpdateDropdown(dropdown, config, default)
    if dropdown and config then
        local players = getPlayers()
        local currentSelection = config.SelectedPlayer or default
        local selectionExists = table.find(players, currentSelection)
        
        dropdown:Refresh(players)
        dropdown:Select(selectionExists and currentSelection or default)
        config.SelectedPlayer = selectionExists and currentSelection or default
    end
end

local function updateTeleportDropdown()
    safeUpdateDropdown(TeleportDropdown, TeleportConfig, "Ninguém")
end

local function updateSpectateDropdown()
    safeUpdateDropdown(SpectateDropdown, SpectateConfig, "Ninguém")
end

local function updateSpamDropdown()
    safeUpdateDropdown(SpamDropdown, SpamConfig, "Ninguém")
end

-- Initial updates
updateTeleportDropdown()
updateSpectateDropdown()
updateSpamDropdown()

-- Select first tab and show notification
WindUI:Notify({
    Title = "Script Fully Loaded!",
    Content = "Happy using, remembering that all functions are undetectable!",
    Duration = 10
})

Tabs.Premium:Section({ Title = "Robux Weapons" })
do
	local selectedIndex = 1
	local indexToCode = {
		[1] = "SS4",
		[2] = "SS5",
		[3] = "SS6",
		[4] = "SS9",
		[5] = "SSS1",
		[6] = "SSS2",
		[7] = "SSS3",
		[8] = "SSSSSS2",
		[9] = "SSSSSS9",
		[10] = "SSSSSSS1",
		[11] = "SSSSSSS3",
		[12] = "SSSSSSS5",
		[13] = "SSSSSSS6",
		[14] = "SSSSSSSS6",
		[15] = "SSSSSSSS7",
	}
	Tabs.Premium:Dropdown({
		Title = "Robux Weapons",
		Desc = "Choose a weapon index",
		Values = {"1","2","3","4","5","6","7","8","9","10","11","12","13","14","15"},
		Multi = false,
		Default = "1",
		Callback = function(v)
			selectedIndex = tonumber(v) or 1
		end
	})
	Tabs.Premium:Button({
		Title = "Use Weapon",
		Desc = "Equip and apply selected weapon",
		Callback = function()
			local Players = game:GetService('Players')
			local ReplicatedStorage = game:GetService('ReplicatedStorage')
			local RunService = game:GetService('RunService')
			local MarketplaceService = game:GetService('MarketplaceService')
			local code = indexToCode[selectedIndex]
			if not code then
				WindUI:Notify({Title = "Weapons", Content = "Invalid selection", Duration = 2})
				return
			end
			local args = { code }
			pcall(function()
				ReplicatedStorage:WaitForChild('Events'):WaitForChild('WeaponEvent'):FireServer(unpack(args))
			end)
			local function ownsPass(player, passId)
				if RunService:IsStudio() then
					return true
				end
				local ok, owns = pcall(MarketplaceService.UserOwnsGamePassAsync, MarketplaceService, player.UserId, passId)
				return ok and owns
			end
			ownsPass(Players.LocalPlayer, 0)
			local p = Players.LocalPlayer
			local c = p.Character or p.CharacterAdded:Wait()
			local h = c:FindFirstChildOfClass('Humanoid')
			if h then
				h.Health = 0
			end
			WindUI:Notify({Title = "Weapons", Content = "Applied weapon: "..tostring(code), Duration = 2})
		end
	})
end

local TargetedPlayer = nil