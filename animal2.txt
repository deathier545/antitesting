-- Load Wind UI Library
local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()

loadstring(game:HttpGet("https://raw.githubusercontent.com/deathier545/antitesting/refs/heads/main/unlockanimals"))()

-- Create window
local Window = WindUI:CreateWindow({
    Title = "Moon HUB (Animal Simulator)",
    Icon = "moon",
    Author = "d1_ofc and onlydecisions",
    Folder = "MoonHUB",
    Size = UDim2.fromOffset(580, 460),
    Theme = "Dark",
    SideBarWidth = 170,
    HasOutline = true
})

-- Create tabs
local Tabs = {
    Farm = Window:Tab({Title = "Farm", Icon = "package"}),
    PVP = Window:Tab({Title = "PvP", Icon = "sword"}),
    Teleport = Window:Tab({Title = "Teleport", Icon = "map-pin"}),
    Misc = Window:Tab({Title = "Misc", Icon = "box"}),
    TargetTab = Window:Tab({ Title = "Target", Icon = "circle-user-round"}),
    Scripts = Window:Tab({Title = "Scripts", Icon = "code"}),
    Skins = Window:Tab({Title = "Skins", Icon = "shirt"}),
    Premium = Window:Tab({Title = "Premium", Icon = "gem"}),
    Settings = Window:Tab({Title = "Settings", Icon = "settings"})
}

Window:SelectTab(1)

local Players = game:GetService("Players")
local plr = Players.LocalPlayer

local RS = game:GetService("ReplicatedStorage")
local Events = RS:WaitForChild("Events")
local SpawnEvent = Events:WaitForChild("SpawnEvent")
local PlotSystemRE = RS:WaitForChild("PlotSystemRE")

Tabs.Premium:Section({ Title = "God mode" })

-- Complete Godmode System (from unlockanimals.txt)
local godmodeActive = false
local currentGodmodeAnimal = nil
local savedPosition = nil
local godmodeThread = nil
local godmodeToggleEnabled = false

-- Animal selection dropdown (for Player Godmode)
local gmOptions = {
    "Player", "Cow", "Mantis", "Deer", "Pig", "Bear", "Frog",
    "Crab", "Squirrel", "Eagle", "Giraffe", "Horse", "Capybara",
    "Snake", "Croc", "Axo", "Rainbow Chicken", "Black Chicken"
}
local gmSelected = gmOptions[1]

Tabs.Premium:Dropdown({
    Title = "Select Target",
    Values = gmOptions,
    Multi = false,
    Default = gmSelected,
    Callback = function(choice)
        if type(choice) == "table" then
            gmSelected = choice[1] or tostring(choice)
        else
            gmSelected = tostring(choice)
        end
    end
})

-- Godmode Toggle
Tabs.Premium:Toggle({
    Title = "Godmode Toggle",
    Desc = "Enable/disable godmode for animal spawning",
    Value = false,
    Callback = function(state)
        godmodeToggleEnabled = state
        WindUI:Notify({
            Title = "Godmode Toggle",
            Content = state and "Godmode ENABLED - clicking animals will now run godmode" or "Godmode DISABLED - clicking animals will only spawn normally",
            Duration = 2
        })
    end
})

-- Player Godmode Button (original animal2.txt functionality)
Tabs.Premium:Button({
    Title = "Player Godmode",
    Desc = "Run the original godmode flow (only works when 'Player' is selected)",
    Callback = function()
        if gmSelected ~= "Player" then
            WindUI:Notify({
                Title = "Error",
                Content = "Player Godmode only works when 'Player' is selected!",
                Duration = 2
            })
            return
        end
        
        local savedPos = plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") and plr.Character.HumanoidRootPart.Position or nil
        local spawnArgs = {"monkey", "monke", "monkeyAnim"}
        local plotArgs = {"buyPlot", "2"}
        local targetPos = Vector3.new(146, 643, 427)
        
        WindUI:Notify({Title = "Player Godmode", Content = "Started", Duration = 2})
        
        if plr.Character and plr.Character:FindFirstChildOfClass("Humanoid") then 
            plr.Character:FindFirstChildOfClass("Humanoid").Health = 0 
        end
        
        local active = true
        task.spawn(function()
            local hrp = nil
            while active do
                local char = plr.Character
                hrp = char and char:FindFirstChild("HumanoidRootPart")
                pcall(function() 
                    SpawnEvent:FireServer(unpack(spawnArgs)) 
                    PlotSystemRE:FireServer(unpack(plotArgs)) 
                end)
                if hrp and targetPos and (hrp.Position - targetPos).Magnitude < 1 then 
                    break 
                end
                task.wait()
            end
            if active and hrp and savedPos then 
                task.wait(1) 
                hrp.CFrame = CFrame.new(savedPos) 
                WindUI:Notify({Title = "Player Godmode", Content = "Returned", Duration = 2}) 
            end
            active = false
            WindUI:Notify({Title = "Player Godmode", Content = "Stopped", Duration = 2})
        end)
    end
})

-- Complete Animal Mapping System (from unlockanimals.txt)
local map = {
    Axolotl = {id = "axolotl", anim = "axolotl_Anim"},
    BTrex = {id = "babydino", anim = "btrexAnim"},
    BabyCat = {id = "babycats", anim = "babycatAnim"},
    BabyElephant = {
        id = "baby_elephant", anim = "babyelephantAnim", gamepassPassId = 89053083,
        skinIdOverrides = {
            elephant1 = "elephant1", elephant2 = "elephant2", elephant3 = "elephant3", elephant4 = "elephant4", elephant5 = "elephant5",
            elephant6 = "elephant6", elephant7 = "elephant7", elephant8 = "elephant8", elephant9 = "elephant9", elephant10 = "elephant10",
            elephant11 = "elephant11", elephant12 = "elephant12", elephant13 = "elephant13", elephant14 = "elephant14", elephant15 = "elephant15",
            elephant16 = "elephant16", elephant17 = "elephant17", elephant18 = "elephant18", elephant19 = "elephant19", elephant20 = "elephant20",
            elephant21 = "elephant21", elephant22 = "elephant22", elephant23 = "elephant23",
            elephant24 = "gamepass24", elephant27 = "gamepass27", elephant28 = "gamepass28", elephant29 = "gamepass29",
            elephant30 = "gamepass30", elephant31 = "gamepass31"
        },
        animOverrides = {
            elephant24 = "babytankelephantAnim", elephant27 = "babytankelephantAnim", elephant28 = "babytankelephantAnim",
            elephant29 = "babytankelephantAnim", elephant30 = "babytankelephantAnim", elephant31 = "babytankelephantAnim"
        }
    },
    BabyKangaroo = {id = "baby_kangaroos", anim = "baby_kangarooAnim"},
    BabyLionRework = {
        id = "babylion_rework", anim = "babylionR_Anim", gamepassPassId = 121800750,
        skinIdOverrides = {
            lion1 = "babylion1", lion2 = "babylion2", lion3 = "babylion3", lion4 = "babylion4", lion5 = "babylion5",
            lion6 = "babylion6", lion7 = "babylion7", lion8 = "babylion8", lion9 = "babylion9", lion10 = "babylion10",
            lion11 = "babylion11", lion12 = "babylion12", lion13 = "babylion13", lion14 = "babylion14", lion15 = "babylion15",
            lion16 = "babylion16"
        },
        animOverrides = {
            gamepass17 = "babylionRWing_Anim", gamepass18 = "babylionRWing_Anim",
            gamepass21 = "babygriffin_Anim", gamepass22 = "babygriffin_Anim", gamepass23 = "babygriffin_Anim",
            gamepass24 = "babygriffin_Anim", gamepass25 = "babygriffin_Anim", gamepass26 = "babygriffin_Anim"
        }
    },
    BabyPenguin = {id = "baby_penguin", anim = "babypenguinAnim"},
    BabyWolf = {
        id = "baby_wolf", anim = "babywolf1Anim", gamepassPassId = 38950138,
        skinIdOverrides = {
            babywolf1 = "baby_wolf1", babywolf2 = "baby_wolf2", babywolf3 = "baby_wolf3", babywolf4 = "baby_wolf4",
            babywolf5 = "baby_wolf5", babywolf6 = "baby_wolf6", babywolf7 = "baby_wolf7", babywolf8 = "baby_wolf8",
            babywolf9 = "baby_wolf9", babywolf10 = "baby_wolf10", babywolf11 = "baby_wolf11", babywolf12 = "baby_wolf12",
            babywolf13 = "baby_wolf13", babywolf14 = "baby_wolf14", babywolf15 = "baby_wolf15", babywolf16 = "baby_wolf16",
            babywolf17 = "baby_wolf17",
            babywolf18 = "gamepass18", babywolf19 = "gamepass19", babywolf20 = "gamepass20", babywolf21 = "gamepass21",
            babywolf22 = "gamepass22", babywolf23 = "gamepass23", babywolf24 = "gamepass24"
        },
        animOverrides = {
            babywolf1 = "babywolf1Anim", babywolf2 = "babywolf1Anim", babywolf3 = "babywolf1Anim", babywolf4 = "babywolf1Anim",
            babywolf5 = "babywolf1Anim", babywolf6 = "babywolf1Anim", babywolf7 = "babywolf1Anim", babywolf8 = "babywolf1Anim",
            babywolf9 = "babywolf1Anim", babywolf10 = "babywolf1Anim", babywolf11 = "babywolf1Anim", babywolf12 = "babywolf1Anim",
            babywolf13 = "babywolf1Anim", babywolf14 = "babywolf1Anim",
            babywolf15 = "babywolf2Anim", babywolf16 = "babywolf2Anim", babywolf17 = "babywolf2Anim",
            babywolf18 = "babywolf3Anim", babywolf19 = "babywolf3Anim", babywolf20 = "babywolf3Anim", babywolf21 = "babywolf3Anim",
            babywolf22 = "babywolf3Anim", babywolf23 = "babywolf3Anim", babywolf24 = "babywolf3Anim"
        }
    },
    Bear = {id = "bears", anim = "bearAnim"},
    Capybara = {id = "capybara", anim = "capybaraAnim"},
    Cat = {id = "cats", anim = "catAnim"},
    Centaur = {id = "centaur", anim = "centaurAnim"},
    Chicken = {id = "chicken", anim = "chickenAnim"},
    Christmas2023 = {
        id = "christmas2023", anim = "newhorseAnim", gamepassPassId = 670590394,
        skinIdOverrides = {
            capybara = "capybara1", snake = "snake1", crocodile = "crocodile1", horse = "horse1", giraffe = "giraffe1",
            gamepass_horse = "gamepass_horse", gamepass_giraffe1 = "gamepass_giraffe1", gamepass_giraffe2 = "gamepass_giraffe2",
            gamepass_babywolf = "gamepass_babywolf", gamepass_wolf = "gamepass_wolf"
        },
        animOverrides = {
            capybara = "capybaraAnim", snake = "snakeAnim", crocodile = "crocodileAnim", horse = "newhorseAnim", giraffe = "giraffeAnim",
            gamepass_horse = "newhorseAnim", gamepass_giraffe1 = "christmasgiraffeAnim", gamepass_giraffe2 = "christmasgiraffeAnim",
            gamepass_babywolf = "babywolf1Anim", gamepass_wolf = "wolf1Anim"
        },
        tokenOverrides = {capybara = "XM23CP", snake = "XM23SN", crocodile = "XM23CR", horse = "XM23HR", giraffe = "XM23GR"}
    },
    Christmas2024 = {id = "christmas2024", anim = "newbear2Anim"},
    Cow = {id = "cows", anim = "cowAnim"},
    Crab = {id = "crab", anim = "crabAnim"},
    Crocodile = {id = "crocodile", anim = "crocodileAnim"},
    Dragon = {id = "dragons", anim = "dragonAnim"},
    Eagle = {id = "eagle", anim = "eagleAnim"},
    Elephant = {id = "elephant", anim = "elephantAnim"},
    Fox = {id = "fox", anim = "foxAnim"},
    Frog = {id = "frog", anim = "frogAnim"},
    Giraffe = {id = "giraffe", anim = "giraffeAnim"},
    Gorilla = {id = "gorilla", anim = "gorillaAnim"},
    Halloween2023 = {
        id = "halloween2023", anim = "newhorseAnim", gamepassPassId = 270811024,
        animOverrides = {
            horse = "newhorseAnim", capybara = "capybaraAnim", crocodile = "crocodileAnim",
            monkey = "halloweenmonkeyAnim", dragon = "dragonAnim", snake = "snakeAnim",
            gamepass_lion = "reworklion_Anim", gamepass_lioness = "reworklion_Anim",
            gamepass_babylion = "babylionR_Anim", gamepass_dragon = "dragonAnim",
            gamepass_monkey = "halloweenmonkeyAnim", gamepass_horse = "newhorseAnim"
        },
        tokenOverrides = {horse = "H23HR", capybara = "H23CP", crocodile = "H23CR", monkey = "H23MK", dragon = "H23DR", snake = "H23SN"}
    },
    Horse = {id = "horse", anim = "horseAnim"},
    Husky = {id = "husky", anim = "huskyAnim"},
    Hyena = {id = "hyena", anim = "hyenaAnim"},
    Kangaroo = {id = "kangaroos", anim = "kangarooAnim"},
    Komodo = {id = "komodo", anim = "komodoAnim"},
    LionRework = {id = "lion_rework", anim = "reworklion_Anim"},
    LionessRework = {id = "lioness_rework", anim = "reworklion_Anim"},
    Mantis = {id = "mantis", anim = "mantisAnim"},
    Monkey = {id = "monkey", anim = "monkeyAnim"},
    NewBear = {id = "newbears", anim = "newbearAnim"},
    NewDeer = {id = "newdeer", anim = "newdeerAnim"},
    NewHorse = {id = "newhorse", anim = "newhorseAnim"},
    Old = {id = "old", anim = "lionAnim", animOverrides = {
        mysticpanther = "lionessAnim", greywolf = "wolfAnim", brownlion = "lionAnim", brownlioness = "lionessAnim",
        baby_brownlion = "babylionAnim", brown_cerberus = "cerberusAnim", jaguar = "lionessAnim", mysticlion = "lionAnim", mysticwolf = "wolfAnim", blackpanther = "lionessAnim"
    }},
    Penguin = {id = "penguin", anim = "penguinAnim", skinIdOverrides = {
        police2 = "police1_penguin", police1 = "police2_penguin", yellow_samuraipenguin = "gamepass1", red_samuraipenguin = "gamepass2", blue_samuraipenguin = "gamepass3"
    }, animOverrides = {gamepass1 = "premPenguinAnim", gamepass2 = "premPenguinAnim", gamepass3 = "premPenguinAnim"}},
    Pig = {id = "pigs", anim = "pigAnim", animOverrides = {
        babypig1 = "babypigAnim", babypig2 = "babypigAnim", babypig3 = "babypigAnim",
        gamepass1 = "pig2Anim", gamepass2 = "pig2Anim", gamepass3 = "pig2Anim", gamepass4 = "pig2Anim"
    }},
    Rabbit = {id = "rabbit", anim = "rabbitAnim", skinIdOverrides = {anime_rabbit = "gamepass1", police_rabbit = "gamepass2", white_rabbit = "gamepass3"}, animOverrides = {
        gamepass1 = "premRabbitAnim", gamepass2 = "premRabbitAnim", gamepass3 = "premRabbitAnim"
    }},
    Rhino = {id = "rhino", anim = "rhinoAnim"},
    Skeleton = {id = "skeletons", anim = "skeleton_deerAnim", animOverrides = {
        deer_1 = "skeleton_deerAnim", rhino_1 = "skeleton_rhinoAnim", trex_1 = "skeleton_trexAnim", wolf_1 = "skeleton_wolfAnim",
        gamepass_deer2 = "skeleton_deerAnim", gamepass_deer3 = "skeleton_deerAnim",
        gamepass_rhino2 = "skeleton_rhinoAnim", gamepass_rhino3 = "skeleton_rhinoAnim",
        gamepass_trex2 = "skeleton_trexAnim", gamepass_trex3 = "skeleton_trexAnim",
        gamepass_wolf2 = "skeleton_wolfAnim", gamepass_wolf3 = "skeleton_wolfAnim"
    }},
    Snake = {id = "snakes", anim = "snakeAnim", animOverrides = {
        gamepass1 = "snakeAnim2", gamepass2 = "snakeAnim2", gamepass3 = "snakeAnim2", gamepass4 = "snakeAnim2", gamepass5 = "snakeAnim2"
    }},
    Spider = {id = "spider", anim = "spiderAnim"},
    Squirrel = {id = "squirrel", anim = "squirrelAnim", animOverrides = {
        gamepass1 = "squirrel2Anim", gamepass2 = "squirrel2Anim", gamepass3 = "squirrel2Anim", gamepass4 = "squirrel2Anim", gamepass5 = "squirrel2Anim"
    }},
    Tiger = {id = "tiger", anim = "tigerAnim", animOverrides = {
        circle_grey = "babytigerAnim", orange_babytiger = "babytigerAnim", white_babytiger = "babytigerAnim", stripe_grey = "babytigerAnim",
        gamepass1 = "premTigerAnim", gamepass2 = "premTigerAnim", gamepass3 = "premTigerAnim"
    }},
    Valentines2024 = {id = "valentines2024", anim = "pegasusAnim", animOverrides = {
        capybara1 = "capybaraAnim", eagle1 = "eagleAnim", eagle2 = "eagleAnim", giraffe1 = "giraffeAnim", giraffe2 = "giraffeAnim", horse1 = "pegasusAnim", horse2 = "pegasusAnim", snake1 = "snakeAnim"
    }},
    WolfRework = {id = "wolf_rework", anim = "wolf1Anim", skinIdOverrides = {
        wolf18 = "gamepass18", wolf19 = "gamepass19", wolf20 = "gamepass20", wolf21 = "gamepass21", wolf22 = "gamepass22", wolf23 = "gamepass23", wolf24 = "gamepass24"
    }, animOverrides = {
        wolf15 = "wolf2Anim", wolf16 = "wolf2Anim",
        wolf18 = "wolf3Anim", wolf19 = "wolf3Anim", wolf20 = "wolf3Anim", wolf21 = "wolf3Anim", wolf22 = "wolf3Anim", wolf23 = "wolf3Anim", wolf24 = "wolf3Anim"
    }},
}

-- Complete Godmode Functions (from unlockanimals.txt)
local function startGodmode(animalId, skinId, anim, token)
    if godmodeActive then return end
    
    godmodeActive = true
    currentGodmodeAnimal = animalId
    
    -- Save current position
    if plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
        savedPosition = plr.Character.HumanoidRootPart.Position
    end
    
    -- Kill player to start godmode process
    if plr.Character and plr.Character:FindFirstChildOfClass("Humanoid") then
        plr.Character:FindFirstChildOfClass("Humanoid").Health = 0
    end
    
    -- Start godmode loop (matching original rayfield logic)
    godmodeThread = task.spawn(function()
        local active = true
        local hrp = nil
        local targetPos = Vector3.new(146, 643, 427)
        local close = false
        local phase1 = false
        
        while active and godmodeActive do
            local char = plr.Character
            hrp = char and char:FindFirstChild("HumanoidRootPart")
            
            if hrp then
                -- Check if we're close to target position
                local distance = (hrp.Position - targetPos).Magnitude
                if distance < 5 then
                    close = true
                    phase1 = true
                end
                
                if not phase1 then
                    -- Phase 1: Get close to target position
                    if token then
                        SpawnEvent:FireServer(animalId, skinId, anim, token)
                    else
                        SpawnEvent:FireServer(animalId, skinId, anim)
                    end
                    
                    if distance > 1 then
                        hrp.CFrame = CFrame.new(targetPos)
                    end
                elseif close then
                    -- Phase 2: Rapid spawning when close
                    local startTime = tick()
                    while active and godmodeActive and (tick() - startTime) < 2 do
                        if token then
                            SpawnEvent:FireServer(animalId, skinId, anim, token)
                        else
                            SpawnEvent:FireServer(animalId, skinId, anim)
                        end
                        task.wait(0.1)
                    end
                    
                    -- Return to saved position
                    if active and godmodeActive and savedPosition then
                        task.wait(1)
                        hrp.CFrame = CFrame.new(savedPosition)
                        break
                    end
                end
                
                task.wait(0.05)
            else
                task.wait()
            end
        end
        
        godmodeActive = false
        currentGodmodeAnimal = nil
        godmodeThread = nil
    end)
end

local function stopGodmode()
    godmodeActive = false
    currentGodmodeAnimal = nil
    
    -- Cancel the godmode thread
    if godmodeThread then
        task.cancel(godmodeThread)
        godmodeThread = nil
    end
    
    -- Return to saved position immediately
    if plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") and savedPosition then
        plr.Character.HumanoidRootPart.CFrame = CFrame.new(savedPosition)
    end
end

-- Animal Spawn Function (adapted for WindUI)
local function spawnAnimal(animalName, skinName)
    local animalConfig = map[animalName]
    if not animalConfig then
        WindUI:Notify({
            Title = "Error",
            Content = "Invalid animal selection: " .. tostring(animalName),
            Duration = 2
        })
        return
    end
    
    -- Set current godmode animal
    currentGodmodeAnimal = animalConfig.id
    
    -- Determine skin and animation
    local skinId = skinName or animalConfig.id
    local anim = animalConfig.anim
    
    -- Handle skin overrides
    if animalConfig.skinIdOverrides and animalConfig.skinIdOverrides[skinName] then
        skinId = animalConfig.skinIdOverrides[skinName]
    end
    
    -- Handle animation overrides
    if animalConfig.animOverrides and animalConfig.animOverrides[skinName] then
        anim = animalConfig.animOverrides[skinName]
    end
    
    -- Handle token overrides
    local token = nil
    if animalConfig.tokenOverrides and animalConfig.tokenOverrides[skinName] then
        token = animalConfig.tokenOverrides[skinName]
    end
    
    -- Always spawn the animal normally
    if token then
        SpawnEvent:FireServer(animalConfig.id, skinId, anim, token)
    else
        SpawnEvent:FireServer(animalConfig.id, skinId, anim)
    end
    
    -- Only run godmode if toggle is enabled
    if not godmodeToggleEnabled then
        WindUI:Notify({
            Title = "Animal Spawned",
            Content = "Spawned " .. animalName .. " (Godmode disabled)",
            Duration = 2
        })
        return
    end
    
    WindUI:Notify({
        Title = "Godmode Started",
        Content = "Starting godmode for " .. animalName,
        Duration = 2
    })
    
    -- Save the starting position BEFORE killing the player
    local savedPos = nil
    if plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
        savedPos = plr.Character.HumanoidRootPart.Position
    end
    
    local plotArgs = {"buyPlot", "2"}
    local targetPos = Vector3.new(146, 643, 427)
    
    -- Kill player AFTER saving position
    if plr.Character and plr.Character:FindFirstChildOfClass("Humanoid") then 
        plr.Character:FindFirstChildOfClass("Humanoid").Health = 0 
    end
    
    local active = true
    task.spawn(function()
        local hrp = nil
        local close = false
        local phase1 = false
        
        -- Phase 1: Get close to target position
        while active and not phase1 do
            local char = plr.Character
            hrp = char and char:FindFirstChild("HumanoidRootPart")
            
            if hrp then
                local d = (hrp.Position - targetPos).Magnitude
                if d < 5 then
                    close = true
                    phase1 = true
                else
                    -- Fire both remotes together
                    if token then
                        pcall(function() 
                            SpawnEvent:FireServer(animalConfig.id, skinId, anim, token)
                            PlotSystemRE:FireServer(unpack(plotArgs))
                        end)
                    else
                        pcall(function() 
                            SpawnEvent:FireServer(animalConfig.id, skinId, anim)
                            PlotSystemRE:FireServer(unpack(plotArgs))
                        end)
                    end
                end
            end
            task.wait(0.05)
        end
        
        -- Phase 2: Rapid spawning when close
        if active and close then
            local s = tick()
            while active and (tick() - s) < 2 do
                pcall(function() PlotSystemRE:FireServer(unpack(plotArgs)) end)
                task.wait(0.1)
            end
        end
        
        -- Return logic
        if active and close then
            hrp = plr.Character and plr.Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                local fd = (hrp.Position - targetPos).Magnitude
                if fd < 10 and savedPos then
                    task.wait(1)
                    hrp.CFrame = CFrame.new(savedPos)
                    WindUI:Notify({
                        Title = "Godmode",
                        Content = "Returned to saved position",
                        Duration = 2
                    })
                else
                    WindUI:Notify({
                        Title = "Godmode",
                        Content = "Failed to return: " .. math.floor(fd),
                        Duration = 2
                    })
                end
            end
        end
        
        active = false
        WindUI:Notify({
            Title = "Godmode",
            Content = "Stopped",
            Duration = 2
        })
    end)
end

-- Instructions
Tabs.Premium:Section({ Title = "Instructions" })
Tabs.Premium:Paragraph({
    Title = "How to use",
    Desc = "Use the animal buttons below to spawn animals. If Godmode Toggle is OFF, clicking will just spawn the animal. If Godmode Toggle is ON, clicking will run the full godmode script. Use 'Player Godmode' button for the original player godmode functionality."
})

-- Animal Spawning Section
Tabs.Premium:Section({ Title = "Animal Spawning" })

-- Basic Animals
Tabs.Premium:Button({
    Title = "ðŸ„ Spawn Cow",
    Desc = "Spawn a cow (with godmode if enabled)",
    Callback = function()
        spawnAnimal("Cow")
    end
})

Tabs.Premium:Button({
    Title = "ðŸ¸ Spawn Frog",
    Desc = "Spawn a frog (with godmode if enabled)",
    Callback = function()
        spawnAnimal("Frog")
    end
})

Tabs.Premium:Button({
    Title = "ðŸ» Spawn Bear",
    Desc = "Spawn a bear (with godmode if enabled)",
    Callback = function()
        spawnAnimal("Bear")
    end
})

Tabs.Premium:Button({
    Title = "ðŸ¦… Spawn Eagle",
    Desc = "Spawn an eagle (with godmode if enabled)",
    Callback = function()
        spawnAnimal("Eagle")
    end
})

Tabs.Premium:Button({
    Title = "ðŸ¦’ Spawn Giraffe",
    Desc = "Spawn a giraffe (with godmode if enabled)",
    Callback = function()
        spawnAnimal("Giraffe")
    end
})

Tabs.Premium:Button({
    Title = "ðŸŽ Spawn Horse",
    Desc = "Spawn a horse (with godmode if enabled)",
    Callback = function()
        spawnAnimal("Horse")
    end
})

Tabs.Premium:Button({
    Title = "ðŸ¦¥ Spawn Capybara",
    Desc = "Spawn a capybara (with godmode if enabled)",
    Callback = function()
        spawnAnimal("Capybara")
    end
})

Tabs.Premium:Button({
    Title = "ðŸ Spawn Snake",
    Desc = "Spawn a snake (with godmode if enabled)",
    Callback = function()
        spawnAnimal("Snake")
    end
})

Tabs.Premium:Button({
    Title = "ðŸŠ Spawn Crocodile",
    Desc = "Spawn a crocodile (with godmode if enabled)",
    Callback = function()
        spawnAnimal("Crocodile")
    end
})

Tabs.Premium:Button({
    Title = "ðŸ¦Ž Spawn Axolotl",
    Desc = "Spawn an axolotl (with godmode if enabled)",
    Callback = function()
        spawnAnimal("Axo")
    end
})

Tabs.Premium:Button({
    Title = "ðŸ¦€ Spawn Crab",
    Desc = "Spawn a crab (with godmode if enabled)",
    Callback = function()
        spawnAnimal("Crab")
    end
})

Tabs.Premium:Button({
    Title = "ðŸ¿ï¸ Spawn Squirrel",
    Desc = "Spawn a squirrel (with godmode if enabled)",
    Callback = function()
        spawnAnimal("Squirrel")
    end
})

-- Special Animals
Tabs.Premium:Button({
    Title = "ðŸ‰ Spawn Dragon",
    Desc = "Spawn a dragon (with godmode if enabled)",
    Callback = function()
        spawnAnimal("Dragon")
    end
})

Tabs.Premium:Button({
    Title = "ðŸ¦ Spawn Lion",
    Desc = "Spawn a lion (with godmode if enabled)",
    Callback = function()
        spawnAnimal("LionRework")
    end
})

Tabs.Premium:Button({
    Title = "ðŸ¯ Spawn Tiger",
    Desc = "Spawn a tiger (with godmode if enabled)",
    Callback = function()
        spawnAnimal("Tiger")
    end
})

Tabs.Premium:Button({
    Title = "ðŸ¦Š Spawn Fox",
    Desc = "Spawn a fox (with godmode if enabled)",
    Callback = function()
        spawnAnimal("Fox")
    end
})

-- Stop Godmode Button
Tabs.Premium:Button({
    Title = "â¹ï¸ Stop Godmode",
    Desc = "Stop any active godmode process",
    Callback = function()
        if godmodeActive then
            stopGodmode()
            WindUI:Notify({
                Title = "Godmode",
                Content = "Godmode stopped",
                Duration = 2
            })
        else
            WindUI:Notify({
                Title = "Godmode",
                Content = "No godmode active",
                Duration = 2
            })
        end
    end
})

-- Add keyboard controls for godmode
game:GetService("UserInputService").InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    
    if input.KeyCode == Enum.KeyCode.G then
        if godmodeActive then
            stopGodmode()
            WindUI:Notify({
                Title = "Godmode",
                Content = "Godmode stopped",
                Duration = 2
            })
        elseif currentGodmodeAnimal then
            -- Start godmode with current animal
            local cfg = map[currentGodmodeAnimal]
            if cfg then
                startGodmode(cfg.id, cfg.id, cfg.anim)
            end
            WindUI:Notify({
                Title = "Godmode",
                Content = "Godmode started with: " .. currentGodmodeAnimal,
                Duration = 2
            })
        end
    end
end)

-- Cleanup when player leaves
game:GetService("Players").PlayerRemoving:Connect(function(leavingPlayer)
    if leavingPlayer == plr then
        stopGodmode()
    end
end)

--================================================================================
-- FLOOD CONFIGURATION
--================================================================================
local numberOfThreads = 15 -- Number of concurrent workers. 25 is very aggressive.
local useWait = true       -- Keep 'true' for stability. Change to 'false' for maximum risk/power.

--================================================================================
-- TOGGLE AND FLOOD LOGIC
--================================================================================



local isFloodActive = false


local activeThreads = {}

local function startFlood()
    
    local success, remoteEvent = pcall(function()
        return game:GetService("ReplicatedStorage"):WaitForChild("ChickenEvent"):WaitForChild("RemoteEvent")
    end)

    if not success then
        warn("WARNING: Could not find 'ChickenEvent'. This flood thread will not start.")
        return 
    end

    
    while isFloodActive do
        remoteEvent:FireServer({["action"] = "shoot"})
        if useWait then
            task.wait()
        end
    end
end

Tabs.Premium:Section({ Title = "Lag Server" })

Tabs.Premium:Section({ Title = "Instructions" })
Tabs.Premium:Paragraph({
    Title = "How to use",
    Desc = "Just activate the option and the entire server will be laggy and frozen for everyone and after deactivating it, wait a while for it to stop completely. This feature is in testing and will be updated to support every animal simulator update."
})

local LagToggle = Tabs.Premium:Toggle({
    Title = "Lag Server",
    Desc = "Activates/Deactivates the event flood to lag the server.",
    Type = "Checkbox",
    Default = false, 
    Callback = function(state)
        isFloodActive = state

        if isFloodActive then
            -- If the toggle was TURNED ON
            print("======================================================")
            print("[+] Flood ACTIVATED. Starting " .. numberOfThreads .. " threads...")
            print("======================================================")

            -- Clear the old threads table, just in case
            activeThreads = {}

            -- Create and start the new threads
            for i = 1, numberOfThreads do
                local newThread = task.spawn(startFlood)
                table.insert(activeThreads, newThread)
            end
            print(numberOfThreads .. " flood threads are now running.")

        else
            -- If the toggle was TURNED OFF
            print("======================================================")
            print("[-] Flood DEACTIVATED. Stopping all threads...")
            print("======================================================")

            -- Loop through all the threads we created and cancel them
            for i, thread in ipairs(activeThreads) do
                task.cancel(thread) -- Immediately stops the thread's execution
            end

            -- Clear the table to free up memory
            activeThreads = {}
            print("All flood threads have been stopped successfully.")
        end
    end
})

Tabs.Premium:Section({ Title = "Robux Weapons" })
do
	local selectedIndex = 1
	local indexToCode = {
		[1] = "SS4",
		[2] = "SS5",
		[3] = "SS6",
		[4] = "SS9",
		[5] = "SSS1",
		[6] = "SSS2",
		[7] = "SSS3",
		[8] = "SSSSSS2",
		[9] = "SSSSSS9",
		[10] = "SSSSSSS1",
		[11] = "SSSSSSS3",
		[12] = "SSSSSSS5",
		[13] = "SSSSSSS6",
		[14] = "SSSSSSSS6",
		[15] = "SSSSSSSS7",
	}
	Tabs.Premium:Dropdown({
		Title = "Robux Weapons",
		Desc = "Choose a weapon index",
		Values = {"1","2","3","4","5","6","7","8","9","10","11","12","13","14","15"},
		Multi = false,
		Default = "1",
		Callback = function(v)
			selectedIndex = tonumber(v) or 1
		end
	})

    Tabs.Premium:Section({ Title = "Instructions" })
Tabs.Premium:Paragraph({
    Title = "How to use",
    Desc = "Select a sword to use and click the button to equip any robux sword without spending 1 cent. This feature is in testing and will be updated to support every animal simulator update."
})

	Tabs.Premium:Button({
		Title = "Use Weapon",
		Desc = "Equip and apply selected weapon",
		Callback = function()
			local Players = game:GetService('Players')
			local ReplicatedStorage = game:GetService('ReplicatedStorage')
			local RunService = game:GetService('RunService')
			local MarketplaceService = game:GetService('MarketplaceService')
			local code = indexToCode[selectedIndex]
			if not code then
				WindUI:Notify({Title = "Weapons", Content = "Invalid selection", Duration = 2})
				return
			end
			local args = { code }
			pcall(function()
				ReplicatedStorage:WaitForChild('Events'):WaitForChild('WeaponEvent'):FireServer(unpack(args))
			end)
			local function ownsPass(player, passId)
				if RunService:IsStudio() then
					return true
				end
				local ok, owns = pcall(MarketplaceService.UserOwnsGamePassAsync, MarketplaceService, player.UserId, passId)
				return ok and owns
			end
			ownsPass(Players.LocalPlayer, 0)
			local p = Players.LocalPlayer
			local c = p.Character or p.CharacterAdded:Wait()
			local h = c:FindFirstChildOfClass('Humanoid')
			if h then
				h.Health = 0
			end
			WindUI:Notify({Title = "Weapons", Content = "Applied weapon: "..tostring(code), Duration = 2})
		end
	})
end

local TargetedPlayer = nil
local ForceWhitelist = ForceWhitelist or {}
local ScriptWhitelist = ScriptWhitelist or {}

-- VariÃ¡veis adicionais para o sistema de Target
local Velocity_Asset
pcall(function()
    -- Cria um objeto BodyVelocity para controlar movimento em aÃ§Ãµes
    Velocity_Asset = Instance.new("BodyVelocity")
    Velocity_Asset.Name = "BreakVelocity"
    Velocity_Asset.MaxForce = Vector3.new(100000, 100000, 100000)
    Velocity_Asset.Velocity = Vector3.new(0, 0, 0)
end)

-- FunÃ§Ã£o para animar o personagem
local function PlayAnim(id, time, speed)
    pcall(function()
        if not plr.Character or not plr.Character:FindFirstChild("Humanoid") then
            WindUI:Notify({
                Title = "Error",
                Content = "Your character is not ready to animate.",
                Duration = 2
            })
            return
        end
        
        plr.Character.Animate.Disabled = false
        local hum = plr.Character.Humanoid
        local animtrack = hum:GetPlayingAnimationTracks()
        for i, track in pairs(animtrack) do
            track:Stop()
        end
        plr.Character.Animate.Disabled = true
        
        local Anim = Instance.new("Animation")
        Anim.AnimationId = "rbxassetid://"..id
        local loadanim = hum:LoadAnimation(Anim)
        loadanim:Play()
        if time then 
            loadanim.TimePosition = time
        end
        if speed then
            loadanim:AdjustSpeed(speed)
        end
        
        loadanim.Stopped:Connect(function()
            plr.Character.Animate.Disabled = false
            for i, track in pairs(animtrack) do
                track:Stop()
            end
        end)
        
        _G.CurrentAnimation = loadanim
    end)
end

-- FunÃ§Ã£o para parar a animaÃ§Ã£o atual
local function StopAnim()
    pcall(function()
        if plr.Character and plr.Character:FindFirstChild("Humanoid") then
            plr.Character.Animate.Disabled = false
            local animtrack = plr.Character.Humanoid:GetPlayingAnimationTracks()
            for i, track in pairs(animtrack) do
                track:Stop()
            end
        end
        
        _G.CurrentAnimation = nil
    end)
end

-- FunÃ§Ã£o para obter o ping do jogador
local function GetPing()
    local ping = 0
    pcall(function()
        ping = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue() / 1000
    end)
    return ping or 0.2
end

-- FunÃ§Ã£o para obter a ferramenta Push
local function GetPush()
    for _, tool in ipairs(plr.Backpack:GetChildren()) do
        if tool.Name == "Push" or tool.Name == "ModdedPush" then
            return tool
        end
    end
    for _, tool in ipairs(plr.Character:GetChildren()) do
        if tool.Name == "Push" or tool.Name == "ModdedPush" then
            return tool
        end
    end
    return nil
end

-- FunÃ§Ã£o para obter jogador pelo nome/display
local function GetPlayer(UserDisplay)
    if UserDisplay and UserDisplay ~= "" then
        for i,v in pairs(Players:GetPlayers()) do
            if v.Name:lower():match(UserDisplay:lower()) or v.DisplayName:lower():match(UserDisplay:lower()) then
                return v
            end
        end
    end
    return nil
end

-- FunÃ§Ãµes auxiliares Target
local function GetCharacter(Player)
    return Player and Player.Character or nil
end

local function GetRoot(Player)
    local char = GetCharacter(Player)
    if char and char:FindFirstChild("HumanoidRootPart") then
        return char.HumanoidRootPart
    end
    return nil
end

local function TeleportTO(posX,posY,posZ,targetPlayer,method)
    pcall(function()
        local localRoot = GetRoot(plr)
        if not localRoot then return end

        if method == "safe" then
            task.spawn(function()
                for i = 1,30 do
                    task.wait()
                    if localRoot then
                        localRoot.Velocity = Vector3.new(0,0,0)
                        if targetPlayer == "pos" then
                            localRoot.CFrame = CFrame.new(posX,posY,posZ)
                        else
                            local targetRoot = GetRoot(targetPlayer)
                            if targetRoot then
                                localRoot.CFrame = CFrame.new(targetRoot.Position) + Vector3.new(0,2,0)
                            end
                        end
                    end
                end
            end)
        else
            if localRoot then
                localRoot.Velocity = Vector3.new(0,0,0)
                if targetPlayer == "pos" then
                    localRoot.CFrame = CFrame.new(posX,posY,posZ)
                else
                    local targetRoot = GetRoot(targetPlayer)
                    if targetRoot then
                        localRoot.CFrame = CFrame.new(targetRoot.Position) + Vector3.new(0,2,0)
                    end
                end
            end
        end
    end)
end

local function PredictionTP(targetPlayer,method)
    pcall(function()
        local localRoot = GetRoot(plr)
        local targetRoot = GetRoot(targetPlayer)
        if not localRoot or not targetRoot then return end

        local pos = targetRoot.Position
        local vel = targetRoot.Velocity
        local ping = GetPing()

        localRoot.CFrame = CFrame.new(
            (pos.X) + (vel.X) * (ping * 3.5),
            (pos.Y) + (vel.Y) * (ping * 2),
            (pos.Z) + (vel.Z) * (ping * 3.5)
        )

        if method == "safe" then
            task.wait()
            localRoot.CFrame = CFrame.new(pos)
            task.wait()
            localRoot.CFrame = CFrame.new(
                (pos.X) + (vel.X) * (ping * 3.5),
                (pos.Y) + (vel.Y) * (ping * 2),
                (pos.Z) + (vel.Z) * (ping * 3.5)
            )
        end
    end)
end

local function Push(Target)
    -- ImplementaÃ§Ã£o da funÃ§Ã£o Push
    pcall(function()
        local Push = GetPush()
        if Push and Push:FindFirstChild("PushTool") then
            local args = {[1] = Target.Character}
            Push.PushTool:FireServer(unpack(args))
            WindUI:Notify({
                Title = "Push",
                Content = "Empurrando " .. Target.Name,
                Duration = 1
            })
        else
            -- Alternativa se nÃ£o encontrar a ferramenta Push especÃ­fica
            local targetRoot = GetRoot(Target)
            local localRoot = GetRoot(plr)
            if targetRoot and localRoot then
                local direction = (targetRoot.Position - localRoot.Position).Unit
                local force = Instance.new("BodyVelocity")
                force.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                force.Velocity = direction * 50
                force.Parent = targetRoot
                game.Debris:AddItem(force, 0.2)
                WindUI:Notify({
                    Title = "Push",
                    Content = "Empurrando " .. Target.Name,
                    Duration = 1
                })
            end
        end
        
        -- Reequipar ferramentas necessÃ¡rias
        for _, toolName in ipairs({"Push", "ModdedPush", "ClickTarget", "potion"}) do
            if plr.Character:FindFirstChild(toolName) then
                local tool = plr.Character:FindFirstChild(toolName)
                tool.Parent = plr.Backpack
                tool.Parent = plr.Character
            end
        end
    end)
end

-- Paragraph para feedback
local targetFeedback = Tabs.TargetTab:Paragraph({
    Title = "Target Status",
    Desc = "No target selected."
})

-- ParÃ¡grafo adicional para informaÃ§Ãµes do jogador
local targetInfo = Tabs.TargetTab:Paragraph({
    Title = "Player Information",
    Desc = "Select a target to view information."
})

-- BotÃ£o para criar ferramenta de seleÃ§Ã£o de alvo
local CreateTargetTool = function()
    -- Remove ferramenta antiga se existir
    if plr.Backpack:FindFirstChild("ClickTarget") then
        plr.Backpack:FindFirstChild("ClickTarget"):Destroy()
    end
    if plr.Character and plr.Character:FindFirstChild("ClickTarget") then
        plr.Character:FindFirstChild("ClickTarget"):Destroy()
    end

    local GetTargetTool = Instance.new("Tool")
    GetTargetTool.Name = "ClickTarget"
    GetTargetTool.RequiresHandle = false
    GetTargetTool.TextureId = "rbxassetid://6043845934" -- ID corrigido
    GetTargetTool.ToolTip = "Select Target"
    GetTargetTool.CanBeDropped = false

    GetTargetTool.Activated:Connect(function()
        local mouse = plr:GetMouse()
        local hit = mouse.Target
        local person = nil
        
        if hit and hit.Parent then
            if hit.Parent:IsA("Model") then
                person = Players:GetPlayerFromCharacter(hit.Parent)
            elseif hit.Parent:IsA("Accessory") and hit.Parent.Parent then
                person = Players:GetPlayerFromCharacter(hit.Parent.Parent)
            end
            
            if person and person ~= plr then
                WindUI:Notify({
                    Title = "Target Selected",
                    Content = "Current target: " .. person.Name,
                    Duration = 2
                })
                
                -- Atualizar variÃ¡vel TargetedPlayer diretamente
                TargetedPlayer = person
                
                -- Atualizar feedback
                targetFeedback:SetTitle("Target Selected: " .. person.Name)
                targetFeedback:SetDesc("ID: " .. person.UserId .. "\nName: " .. person.DisplayName)
                
                -- Atualizar informaÃ§Ãµes adicionais do jogador
                local infoText = "Name: " .. person.Name
                infoText = infoText .. "\nDisplay: " .. person.DisplayName
                infoText = infoText .. "\nUserID: " .. person.UserId
                infoText = infoText .. "\nEntered: " .. os.date("%d-%m-%Y", os.time() - person.AccountAge * 24 * 3600)
                
                local team = person.Team and person.Team.Name or "None"
                infoText = infoText .. "\nTeam: " .. team
                
                
                targetInfo:SetTitle("Information: " .. person.Name)
                targetInfo:SetDesc(infoText)
                
                -- Salvar referÃªncia global
                _G.TargetedUserId = person.UserId
            elseif person == plr then
                WindUI:Notify({
                    Title = "Error",
                    Content = "You cannot select yourself.",
                    Duration = 2
                })
            else
                -- Limpar alvo
                TargetedPlayer = nil
                _G.TargetedUserId = nil
                
                targetFeedback:SetTitle("Target Status")
                targetFeedback:SetDesc("No target selected.")
                
                targetInfo:SetTitle("Player Information")
                targetInfo:SetDesc("Select a target to view information.")
                
                WindUI:Notify({
                    Title = "Target Removed",
                    Content = "No player selected.",
                    Duration = 2
                })
            end
        end
    end)
    
    GetTargetTool.Parent = plr.Backpack
    GetTargetTool.Parent = plr.Character -- Equipar automaticamente a ferramenta
    
    WindUI:Notify({
        Title = "Tool Created",
        Content = "Use the tool to select a target by clicking on it.",
        Duration = 3
    })
end

Tabs.TargetTab:Button({
    Title = "Grab Selection Tool",
    Desc = "Creates a tool to select targets by clicking on them.",
    Icon = "rbxassetid://6043845934",
    Callback = function()
        CreateTargetTool()
    end
})

Tabs.TargetTab:Section({ Title = "Target Actions" })

-- BotÃ£o Visualizar Alvo - Converter para Toggle
Tabs.TargetTab:Toggle({
    Title = "View Target",
    Desc = "Switches the camera to view the target.",
    Value = false,
    Callback = function(state)
        if not TargetedPlayer then
            WindUI:Notify({
                Title = "Error",
                Content = "No target selected.",
                Duration = 2
            })
            return
        end
        
        if state then
            local humanoid = TargetedPlayer.Character and TargetedPlayer.Character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                workspace.CurrentCamera.CameraSubject = humanoid
                
                WindUI:Notify({
                    Title = "Camera",
                    Content = "Viewing " .. TargetedPlayer.Name,
                    Duration = 2
                })
                
                targetFeedback:SetDesc("Viewing " .. TargetedPlayer.Name)
                
                -- Criar loop para manter a visualizaÃ§Ã£o
                _G.ViewLoop = task.spawn(function()
                    while _G.ViewingTarget and TargetedPlayer and task.wait(0.5) do
                        pcall(function()
                            if TargetedPlayer.Character and TargetedPlayer.Character:FindFirstChild("Humanoid") then
                                workspace.CurrentCamera.CameraSubject = TargetedPlayer.Character.Humanoid
                            end
                        end)
                    end
                end)
                
                _G.ViewingTarget = true
            else
                WindUI:Notify({
                    Title = "Error",
                    Content = "Could not find target character.",
                    Duration = 2
                })
            end
        else
            _G.ViewingTarget = false
            
            if _G.ViewLoop then
                task.cancel(_G.ViewLoop)
                _G.ViewLoop = nil
            end
            
            pcall(function()
                workspace.CurrentCamera.CameraSubject = plr.Character.Humanoid
            end)
            
            WindUI:Notify({
                Title = "Camera",
                Content = "Returning to normal view.",
                Duration = 2
            })
            
            targetFeedback:SetDesc("Alvo: " .. TargetedPlayer.Name)
        end
    end
})

-- BotÃ£o Focar no Alvo - Converter para Toggle
Tabs.TargetTab:Toggle({
    Title = "Focus on the Target",
    Desc = "Follows the target continuously.",
    Value = false,
    Callback = function(state)
        if not TargetedPlayer then
            WindUI:Notify({
                Title = "Error",
                Content = "No target selected.",
                Duration = 2
            })
            return
        end
        
        if state then
            WindUI:Notify({
                Title = "Focus",
                Content = "Following " .. TargetedPlayer.Name,
                Duration = 2
            })
            
            targetFeedback:SetDesc("Focusing on " .. TargetedPlayer.Name)
            
            -- Criar loop para seguir o alvo
            _G.FocusLoop = task.spawn(function()
                _G.FocusingTarget = true
                while _G.FocusingTarget and TargetedPlayer and task.wait(0.2) do
                    pcall(function()
                        TeleportTO(0, 0, 0, TargetedPlayer)
                    end)
                end
            end)
        else
            _G.FocusingTarget = false
            
            if _G.FocusLoop then
                task.cancel(_G.FocusLoop)
                _G.FocusLoop = nil
            end
            
            WindUI:Notify({
                Title = "Focus",
                Content = "Stopped following the target.",
                Duration = 2
            })
            
            targetFeedback:SetDesc("Target: " .. TargetedPlayer.Name)
        end
    end
})

-- BotÃ£o Benx no Alvo - Converter para Toggle
Tabs.TargetTab:Toggle({
    Title = "Beng on Target",
    Desc = "Eat the target's ass.",
    Value = false,
    Callback = function(state)
        if not TargetedPlayer then
            WindUI:Notify({
                Title = "Error",
                Content = "No target selected.",
                Duration = 2
            })
            return
        end
        
        if state then
            -- Iniciar animaÃ§Ã£o
            PlayAnim(5918726674, 0, 1)
            
            WindUI:Notify({
                Title = "Benx",
                Content = "Running Benx on " .. TargetedPlayer.Name,
                Duration = 2
            })
            
            targetFeedback:SetDesc("Running Benx on " .. TargetedPlayer.Name)
            
            -- Criar loop para a posiÃ§Ã£o de Benx
            _G.BenxLoop = task.spawn(function()
                _G.BenxingTarget = true
                while _G.BenxingTarget and TargetedPlayer and task.wait() do
                    pcall(function()
                        local localRoot = GetRoot(plr)
                        local targetRoot = GetRoot(TargetedPlayer)
                        
                        if not localRoot:FindFirstChild("BreakVelocity") then
                            local TempV = Velocity_Asset:Clone()
                            TempV.Parent = localRoot
                        end
                        
                        if localRoot and targetRoot then
                            localRoot.CFrame = targetRoot.CFrame * CFrame.new(0, 0, 1.1) -- PosiÃ§Ã£o frontal exata
                            localRoot.Velocity = Vector3.new(0, 0, 0)
                        end
                    end)
                end
                
                -- Limpar ao terminar
                StopAnim()
                pcall(function()
                    if GetRoot(plr):FindFirstChild("BreakVelocity") then
                        GetRoot(plr).BreakVelocity:Destroy()
                    end
                end)
            end)
        else
            _G.BenxingTarget = false
            
            if _G.BenxLoop then
                task.cancel(_G.BenxLoop)
                _G.BenxLoop = nil
            end
            
            -- Parar animaÃ§Ã£o
            StopAnim()
            pcall(function()
                if GetRoot(plr):FindFirstChild("BreakVelocity") then
                    GetRoot(plr).BreakVelocity:Destroy()
                end
            end)
            
            WindUI:Notify({
                Title = "Benx",
                Content = "Stopped running Benx.",
                Duration = 2
            })
            
            targetFeedback:SetDesc("Target: " .. TargetedPlayer.Name)
        end
    end
})

-- Headsit no Alvo - Converter para Toggle
Tabs.TargetTab:Toggle({
    Title = "Headsit on Target",
    Desc = "Sits on the target's head.",
    Value = false,
    Callback = function(state)
        if not TargetedPlayer then
            WindUI:Notify({
                Title = "Error",
                Content = "No target selected.",
                Duration = 2
            })
            return
        end
        
        if state then
            WindUI:Notify({
                Title = "Headsit",
                Content = "Sitting on the head of " .. TargetedPlayer.Name,
                Duration = 2
            })
            
            targetFeedback:SetDesc("Headsit in " .. TargetedPlayer.Name)
            
            -- Criar loop para a posiÃ§Ã£o de Headsit
            _G.HeadsitLoop = task.spawn(function()
                _G.HeadsittingTarget = true
                while _G.HeadsittingTarget and TargetedPlayer and task.wait() do
                    pcall(function()
                        local localRoot = GetRoot(plr)
                        local targetHead = TargetedPlayer.Character and TargetedPlayer.Character:FindFirstChild("Head")
                        
                        if not localRoot:FindFirstChild("BreakVelocity") then
                            local TempV = Velocity_Asset:Clone()
                            TempV.Parent = localRoot
                        end
                        
                        if localRoot and targetHead and plr.Character and plr.Character:FindFirstChild("Humanoid") then
                            plr.Character.Humanoid.Sit = true
                            localRoot.CFrame = targetHead.CFrame * CFrame.new(0, 2, 0)
                            localRoot.Velocity = Vector3.new(0, 0, 0)
                        end
                    end)
                end
                
                -- Limpar ao terminar
                pcall(function()
                    if GetRoot(plr):FindFirstChild("BreakVelocity") then
                        GetRoot(plr).BreakVelocity:Destroy()
                    end
                end)
            end)
        else
            _G.HeadsittingTarget = false
            
            if _G.HeadsitLoop then
                task.cancel(_G.HeadsitLoop)
                _G.HeadsitLoop = nil
            end
            
            pcall(function()
                if GetRoot(plr):FindFirstChild("BreakVelocity") then
                    GetRoot(plr).BreakVelocity:Destroy()
                end
            end)
            
            WindUI:Notify({
                Title = "Headsit",
                Content = "Stopped sitting on the target's head.",
                Duration = 2
            })
            
            targetFeedback:SetDesc("Target: " .. TargetedPlayer.Name)
        end
    end
})

-- Stand ao Lado do Alvo - Converter para Toggle
Tabs.TargetTab:Toggle({
    Title = "Stand Next to the Target",
    Desc = "Stand next to the target.",
    Value = false,
    Callback = function(state)
        if not TargetedPlayer then
            WindUI:Notify({
                Title = "Error",
                Content = "No target selected.",
                Duration = 2
            })
            return
        end
        
        if state then
            -- Iniciar animaÃ§Ã£o de stand
            PlayAnim(13823324057, 4, 0)
            
            WindUI:Notify({
                Title = "Stand",
                Content = "Standing next to " .. TargetedPlayer.Name,
                Duration = 2
            })
            
            targetFeedback:SetDesc("Stand next to " .. TargetedPlayer.Name)
            
            -- Criar loop para a posiÃ§Ã£o de stand
            _G.StandLoop = task.spawn(function()
                _G.StandingTarget = true
                while _G.StandingTarget and TargetedPlayer and task.wait() do
                    pcall(function()
                        local localRoot = GetRoot(plr)
                        local targetRoot = GetRoot(TargetedPlayer)
                        
                        if not localRoot:FindFirstChild("BreakVelocity") then
                            local TempV = Velocity_Asset:Clone()
                            TempV.Parent = localRoot
                        end
                        
                        if localRoot and targetRoot then
                            localRoot.CFrame = targetRoot.CFrame * CFrame.new(-3, 1, 0) -- PosiÃ§Ã£o lateral exata
                            localRoot.Velocity = Vector3.new(0, 0, 0)
                        end
                    end)
                end
                
                -- Limpar ao terminar
                StopAnim()
                pcall(function()
                    if GetRoot(plr):FindFirstChild("BreakVelocity") then
                        GetRoot(plr).BreakVelocity:Destroy()
                    end
                end)
            end)
        else
            _G.StandingTarget = false
            
            if _G.StandLoop then
                task.cancel(_G.StandLoop)
                _G.StandLoop = nil
            end
            
            -- Parar animaÃ§Ã£o
            StopAnim()
            pcall(function()
                if GetRoot(plr):FindFirstChild("BreakVelocity") then
                    GetRoot(plr).BreakVelocity:Destroy()
                end
            end)
            
            WindUI:Notify({
                Title = "Stand",
                Content = "Stopped standing next to the target.",
                Duration = 2
            })
            
            targetFeedback:SetDesc("Target: " .. TargetedPlayer.Name)
        end
    end
})

-- Backpack no Alvo - Converter para Toggle
Tabs.TargetTab:Toggle({
    Title = "Backpack on Target",
    Desc = "Backpack position on target.",
    Value = false,
    Callback = function(state)
        if not TargetedPlayer then
            WindUI:Notify({
                Title = "Error",
                Content = "No target selected.",
                Duration = 2
            })
            return
        end
        
        if state then
            WindUI:Notify({
                Title = "Backpack",
                Content = "Backpack in " .. TargetedPlayer.Name,
                Duration = 2
            })
            
            targetFeedback:SetDesc("Backpack in " .. TargetedPlayer.Name)
            
            -- Criar loop para a posiÃ§Ã£o de backpack
            _G.BackpackLoop = task.spawn(function()
                _G.BackpackingTarget = true
                while _G.BackpackingTarget and TargetedPlayer and task.wait() do
                    pcall(function()
                        local localRoot = GetRoot(plr)
                        local targetRoot = GetRoot(TargetedPlayer)
                        
                        if not localRoot:FindFirstChild("BreakVelocity") then
                            local TempV = Velocity_Asset:Clone()
                            TempV.Parent = localRoot
                        end
                        
                        if localRoot and targetRoot and plr.Character and plr.Character:FindFirstChild("Humanoid") then
                            plr.Character.Humanoid.Sit = true
                            localRoot.CFrame = targetRoot.CFrame * CFrame.new(0, 0, 1.2) * CFrame.Angles(0, -3, 0)
                            localRoot.Velocity = Vector3.new(0, 0, 0)
                        end
                    end)
                end
                
                -- Limpar ao terminar
                pcall(function()
                    if GetRoot(plr):FindFirstChild("BreakVelocity") then
                        GetRoot(plr).BreakVelocity:Destroy()
                    end
                end)
            end)
        else
            _G.BackpackingTarget = false
            
            if _G.BackpackLoop then
                task.cancel(_G.BackpackLoop)
                _G.BackpackLoop = nil
            end
            
            pcall(function()
                if GetRoot(plr):FindFirstChild("BreakVelocity") then
                    GetRoot(plr).BreakVelocity:Destroy()
                end
            end)
            
            WindUI:Notify({
                Title = "Backpack",
                Content = "Stopped backpacking on target.",
                Duration = 2
            })
            
            targetFeedback:SetDesc("Target: " .. TargetedPlayer.Name)
        end
    end
})

-- Doggy no Alvo - Converter para Toggle
Tabs.TargetTab:Toggle({
    Title = "Doggy on Target",
    Desc = "Dog position on target.",
    Value = false,
    Callback = function(state)
        if not TargetedPlayer then
            WindUI:Notify({
                Title = "Error",
                Content = "No target selected.",
                Duration = 2
            })
            return
        end
        
        if state then
            -- Iniciar animaÃ§Ã£o de doggy
            PlayAnim(13694096724, 3.4, 0)
            
            WindUI:Notify({
                Title = "Doggy",
                Content = "Doggy in " .. TargetedPlayer.Name,
                Duration = 2
            })
            
            targetFeedback:SetDesc("Doggy in " .. TargetedPlayer.Name)
            
            -- Criar loop para a posiÃ§Ã£o de doggy
            _G.DoggyLoop = task.spawn(function()
                _G.DoggyingTarget = true
                while _G.DoggyingTarget and TargetedPlayer and task.wait() do
                    pcall(function()
                        local localRoot = GetRoot(plr)
                        local targetLowerTorso = nil
                        
                        -- Tentar obter o LowerTorso diretamente
                        if TargetedPlayer.Character and TargetedPlayer.Character:FindFirstChild("LowerTorso") then
                            targetLowerTorso = TargetedPlayer.Character.LowerTorso
                        end
                        
                        if not targetLowerTorso then
                            -- Fallback para o root se LowerTorso nÃ£o estiver disponÃ­vel
                            targetLowerTorso = GetRoot(TargetedPlayer)
                        end
                        
                        if not localRoot:FindFirstChild("BreakVelocity") then
                            local TempV = Velocity_Asset:Clone()
                            TempV.Parent = localRoot
                        end
                        
                        if localRoot and targetLowerTorso then
                            localRoot.CFrame = targetLowerTorso.CFrame * CFrame.new(0, 0.23, 0) -- PosiÃ§Ã£o exata do doggy
                            localRoot.Velocity = Vector3.new(0, 0, 0)
                        end
                    end)
                end
                
                -- Limpar ao terminar
                StopAnim()
                pcall(function()
                    if GetRoot(plr):FindFirstChild("BreakVelocity") then
                        GetRoot(plr).BreakVelocity:Destroy()
                    end
                end)
            end)
        else
            _G.DoggyingTarget = false
            
            if _G.DoggyLoop then
                task.cancel(_G.DoggyLoop)
                _G.DoggyLoop = nil
            end
            
            -- Parar animaÃ§Ã£o
            StopAnim()
            pcall(function()
                if GetRoot(plr):FindFirstChild("BreakVelocity") then
                    GetRoot(plr).BreakVelocity:Destroy()
                end
            end)
            
            WindUI:Notify({
                Title = "Doggy",
                Content = "Stopped doing doggy on target.",
                Duration = 2
            })
            
            targetFeedback:SetDesc("Target: " .. TargetedPlayer.Name)
        end
    end
})

-- Sugar no Alvo - Nova animaÃ§Ã£o
Tabs.TargetTab:Toggle({
    Title = "Suck on Target",
    Desc = "Make the target suck you in.",
    Value = false,
    Callback = function(state)
        if not TargetedPlayer then
            WindUI:Notify({
                Title = "Error",
                Content = "No target selected.",
                Duration = 2
            })
            return
        end
        
        if state then
            -- Usar uma animaÃ§Ã£o de "idle" para manter o personagem reto
            pcall(function()
                if plr.Character and plr.Character:FindFirstChild("Humanoid") then
                    -- AnimaÃ§Ã£o de idle/stand
                    PlayAnim(507766666, 0, 0) -- AnimaÃ§Ã£o de ficar em pÃ© reto
                    
                    -- Garantir que o personagem nÃ£o fique inclinado
                    if plr.Character:FindFirstChild("Humanoid") then
                        plr.Character.Humanoid.PlatformStand = true
                    end
                end
            end)
            
            WindUI:Notify({
                Title = "Sugar",
                Content = "Sugar in " .. TargetedPlayer.Name,
                Duration = 2
            })
            
            targetFeedback:SetDesc("Sugar in " .. TargetedPlayer.Name)
            
            -- VariÃ¡vel para controlar a direÃ§Ã£o do movimento
            local moveDirection = 1
            local moveTimer = 0
            
            -- Criar loop para a posiÃ§Ã£o de sugar
            _G.SugarLoop = task.spawn(function()
                _G.SugaringTarget = true
                while _G.SugaringTarget and TargetedPlayer and task.wait() do
                    pcall(function()
                        local localRoot = GetRoot(plr)
                        local targetHead = nil
                        
                        -- Tentar obter a Head diretamente
                        if TargetedPlayer.Character and TargetedPlayer.Character:FindFirstChild("Head") then
                            targetHead = TargetedPlayer.Character.Head
                        end
                        
                        if not targetHead then
                            -- Fallback para o root se Head nÃ£o estiver disponÃ­vel
                            targetHead = GetRoot(TargetedPlayer)
                        end
                        
                        if not localRoot:FindFirstChild("BreakVelocity") then
                            local TempV = Velocity_Asset:Clone()
                            TempV.Parent = localRoot
                        end
                        
                        -- Calcular o offset do movimento para frente e para trÃ¡s
                        moveTimer = moveTimer + 0.1
                        if moveTimer > 1 then
                            moveDirection = -moveDirection
                            moveTimer = 0
                        end
                        
                        -- Offset adicional para o movimento para frente e para trÃ¡s
                        local offset = 0.3 * moveDirection
                        
                        if localRoot and targetHead then
                            -- Posicionar um pouco acima da altura do rosto, Ã  frente e com o movimento para frente e para trÃ¡s
                            -- Usando valores negativos no eixo Z para posicionar na frente do rosto
                            -- Adicionando rotaÃ§Ã£o de 180 graus no eixo Y para virar o personagem na direÃ§Ã£o do alvo
                            -- Valor Y ajustado para ficar mais para cima (0.7)
                            localRoot.CFrame = targetHead.CFrame * CFrame.new(0, 0.7, -(1.5 + offset)) * CFrame.Angles(0, math.rad(180), 0)
                            localRoot.Velocity = Vector3.new(0, 0, 0)
                        end
                    end)
                end
                
                -- Limpar ao terminar
                StopAnim()
                pcall(function()
                    if GetRoot(plr):FindFirstChild("BreakVelocity") then
                        GetRoot(plr).BreakVelocity:Destroy()
                    end
                end)
            end)
        else
            _G.SugaringTarget = false
            
            if _G.SugarLoop then
                task.cancel(_G.SugarLoop)
                _G.SugarLoop = nil
            end
            
            -- Parar animaÃ§Ã£o e restaurar estado normal do personagem
            StopAnim()
            pcall(function()
                if plr.Character and plr.Character:FindFirstChild("Humanoid") then
                    plr.Character.Humanoid.PlatformStand = false
                end
                
                if GetRoot(plr):FindFirstChild("BreakVelocity") then
                    GetRoot(plr).BreakVelocity:Destroy()
                end
            end)
            
            WindUI:Notify({
                Title = "Suck",
                Content = "Stopped making the target suck you in",
                Duration = 2
            })
            
            targetFeedback:SetDesc("Target: " .. TargetedPlayer.Name)
        end
    end
})

-- Drag no Alvo - Nova animaÃ§Ã£o
Tabs.TargetTab:Toggle({
    Title = "Drag on Target",
    Desc = "Get dragged by the target by the hand.",
    Value = false,
    Callback = function(state)
        if not TargetedPlayer then
            WindUI:Notify({
                Title = "Error",
                Content = "No target selected.",
                Duration = 2
            })
            return
        end
        
        if state then
            -- Usar animaÃ§Ã£o de arrastar
            pcall(function()
                if plr.Character and plr.Character:FindFirstChild("Humanoid") then
                    -- AnimaÃ§Ã£o de arrastar (mÃ£o estendida)
                    PlayAnim(10714360343, 0.5, 0)
                    
                    -- Garantir que o personagem nÃ£o fique inclinado
                    if plr.Character:FindFirstChild("Humanoid") then
                        plr.Character.Humanoid.PlatformStand = true
                    end
                end
            end)
            
            WindUI:Notify({
                Title = "Drag",
                Content = "Dragging " .. TargetedPlayer.Name,
                Duration = 2
            })
            
            targetFeedback:SetDesc("Dragging " .. TargetedPlayer.Name)
            
            -- Criar loop para a posiÃ§Ã£o de drag
            _G.DragLoop = task.spawn(function()
                _G.DraggingTarget = true
                while _G.DraggingTarget and TargetedPlayer and task.wait() do
                    pcall(function()
                        local localRoot = GetRoot(plr)
                        local targetRightHand = nil
                        
                        -- Tentar obter a RightHand diretamente
                        if TargetedPlayer.Character and TargetedPlayer.Character:FindFirstChild("RightHand") then
                            targetRightHand = TargetedPlayer.Character.RightHand
                        end
                        
                        if not targetRightHand then
                            -- Fallback para o root se RightHand nÃ£o estiver disponÃ­vel
                            targetRightHand = GetRoot(TargetedPlayer)
                        end
                        
                        if not localRoot:FindFirstChild("BreakVelocity") then
                            local TempV = Velocity_Asset:Clone()
                            TempV.Parent = localRoot
                        end
                        
                        if localRoot and targetRightHand then
                            -- PosiÃ§Ã£o especÃ­fica de arrasto
                            localRoot.CFrame = targetRightHand.CFrame * CFrame.new(0, -2.5, 1) * CFrame.Angles(-2, -3, 0)
                            localRoot.Velocity = Vector3.new(0, 0, 0)
                        end
                    end)
                end
                
                -- Limpar ao terminar
                StopAnim()
                pcall(function()
                    if plr.Character and plr.Character:FindFirstChild("Humanoid") then
                        plr.Character.Humanoid.PlatformStand = false
                    end
                    
                    if GetRoot(plr):FindFirstChild("BreakVelocity") then
                        GetRoot(plr).BreakVelocity:Destroy()
                    end
                end)
            end)
        else
            _G.DraggingTarget = false
            
            if _G.DragLoop then
                task.cancel(_G.DragLoop)
                _G.DragLoop = nil
            end
            
            -- Parar animaÃ§Ã£o e restaurar estado normal do personagem
            StopAnim()
            pcall(function()
                if plr.Character and plr.Character:FindFirstChild("Humanoid") then
                    plr.Character.Humanoid.PlatformStand = false
                end
                
                if GetRoot(plr):FindFirstChild("BreakVelocity") then
                    GetRoot(plr).BreakVelocity:Destroy()
                end
            end)
            
            WindUI:Notify({
                Title = "Drag",
                Content = "Stopped dragging the target.",
                Duration = 2
            })
            
            targetFeedback:SetDesc("Target: " .. TargetedPlayer.Name)
        end
    end
})

-- BotÃ£o Teleportar para o Alvo (sem toggle, aÃ§Ã£o Ãºnica)
Tabs.TargetTab:Button({
    Title = "Teleport to Target",
    Desc = "Teleports to target (single action).",
    Callback = function()
        if not TargetedPlayer then
            WindUI:Notify({
                Title = "Error",
                Content = "No target selected.",
                Duration = 2
            })
            return
        end
        
        TeleportTO(0, 0, 0, TargetedPlayer, "safe")
        
        WindUI:Notify({
            Title = "Teleport",
            Content = "Teleporting for " .. TargetedPlayer.Name,
            Duration = 2
        })
        
        targetFeedback:SetDesc("Teleporting for " .. TargetedPlayer.Name)
    end
})

-- Corrigindo problemas de cÃ³digo duplicado no final do arquivo
-- Atualizar quando o alvo sair do jogo (jÃ¡ parece adequada, apenas garantindo limpeza correta)
Players.PlayerRemoving:Connect(function(player)
    pcall(function()
        if TargetedPlayer and player == TargetedPlayer then
            -- Limpar todos os loops ativos
            for _, loopName in ipairs({"ViewLoop", "FocusLoop", "BenxLoop", "HeadsitLoop", "StandLoop", "BackpackLoop", "DoggyLoop", "SugarLoop", "DragLoop"}) do
                if _G[loopName] then
                    task.cancel(_G[loopName])
                    _G[loopName] = nil
                end
            end
            
            -- Limpar estados
            _G.FlingActive = nil
            _G.ViewingTarget = nil
            _G.FocusingTarget = nil
            _G.BenxingTarget = nil
            _G.HeadsittingTarget = nil
            _G.StandingTarget = nil
            _G.BackpackingTarget = nil
            _G.DoggyingTarget = nil
            _G.SugaringTarget = nil
            _G.DraggingTarget = nil
            
            -- Parar animaÃ§Ãµes e limpar efeitos
            StopAnim()
            pcall(function()
                if GetRoot(plr):FindFirstChild("BreakVelocity") then
                    GetRoot(plr).BreakVelocity:Destroy()
                end
                
                workspace.CurrentCamera.CameraSubject = plr.Character.Humanoid
            end)
            
            WindUI:Notify({
                Title = "Target Out",
                Content = player.Name .. " left the game.",
                Duration = 3
            })
        end
    end)
end)

-- Configurations
local SpamConfig = {
    SelectedPlayer = "NinguÃ©m",
    IsSpamming = false,
    SpamDelay = 0.2,
    SpamMessage = "MoonOnTop"
}

local SpectateConfig = {
    SelectedPlayer = "NinguÃ©m",
    IsSpectating = false,
    Camera = workspace.CurrentCamera
}

local AdminConfig = {
    GroupId = 7625597,
    AdminRank = 2,
    ModeratorRank = 2,
    AlertsEnabled = true
}

local TeleportLocations = {
    {Name = "ðŸ›¡ï¸ Safe Zone", Position = Vector3.new(-105.29137420654297, 642.4719848632812, 514.2374877929688)},
    {Name = "ðŸœï¸ Desert", Position = Vector3.new(-672.6334838867188, 642.568603515625, 1115.691162109375)},
    {Name = "ðŸŒ‹ Volcano", Position = Vector3.new(120.21180725097656, 685.631103515625, 1570.7666015625)},
    {Name = "ðŸ–ï¸ Beach", Position = Vector3.new(-29.751022338867188, 644.6039428710938, -70.5428695678711)},
    {Name = "ðŸŒ«ï¸ Cloud Arena", Position = Vector3.new(-1173.7010498046875, 1268.14404296875, 766.4228515625)}
}

local WalkSpeedConfig = {
    CurrentSpeed = 16,
    MinSpeed = 16,
    MaxSpeed = 500,
    Debounce = false
}

local ESPConfig = {
    FillColor = Color3.fromRGB(175, 25, 255),
    DepthMode = "AlwaysOnTop",
    FillTransparency = 0.5,
    OutlineColor = Color3.fromRGB(255, 255, 255),
    OutlineTransparency = 0,
    Enabled = false
}

-- Global variables
local isFarming = false
local autoEat = false
local dummyFarmActive = false
local dummyFarmConnection = nil
local clanName = ""
local ESPStorage = nil
local ESPConnections = {}
local _G = {
    attackAllNPCToggle = false,
    dummyFarm5kEnabled = false,
    killAura = false,
    huntPlayers = false,
    farmLowLevels = false
}

--[[
    FARM TAB
]]

-- Coin Farm function
local function coinFarmLoop()
    while isFarming and task.wait(0.1) do
        pcall(function()
            game:GetService("ReplicatedStorage").Events.CoinEvent:FireServer()
        end)
    end
end

-- Attack All NPCs function
local function attackAllNPCsLoop()
    while _G.attackAllNPCToggle and task.wait(0.01) do
        pcall(function()
            local npcsWithHealth = {}
            
            for _, npc in ipairs(workspace.NPC:GetDescendants()) do
                if npc:IsA("Humanoid") and npc.Health > 0 then
                    table.insert(npcsWithHealth, {
                        humanoid = npc,
                        health = npc.Health
                    })
                end
            end
            
            table.sort(npcsWithHealth, function(a, b)
                return a.health < b.health
            end)
            
            for _, npcData in ipairs(npcsWithHealth) do
                if _G.attackAllNPCToggle then
                    local args = {
                        [1] = npcData.humanoid,
                        [2] = 1
                    }
                    game:GetService("ReplicatedStorage").jdskhfsIIIllliiIIIdchgdIiIIIlIlIli:FireServer(unpack(args))
                end
            end
        end)
    end
end

-- Dummy Farm function
local function dummyFarmFunction()
    if dummyFarmConnection then
        dummyFarmConnection:Disconnect()
        dummyFarmConnection = nil
    end
    
    if dummyFarmActive then
        dummyFarmConnection = game:GetService("RunService").Heartbeat:Connect(function()
            pcall(function()
                local targetDummy = workspace.MAP.dummies:GetChildren()[1]
                if targetDummy and game.Players.LocalPlayer.Character then
                    local humanoid = targetDummy:FindFirstChild("Humanoid")
                    local rootPart = targetDummy:FindFirstChild("HumanoidRootPart")
                    local playerRoot = game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                    
                    if humanoid and rootPart and playerRoot then
                        playerRoot.CFrame = rootPart.CFrame * CFrame.new(0, 8, 0)
                        game:GetService("ReplicatedStorage").jdskhfsIIIllliiIIIdchgdIiIIIlIlIli:FireServer(humanoid, 1)
                    end
                end
            end)
        end)
    end
end

-- Dummy 5k Farm function
local function dummy5kFarmLoop()
    while _G.dummyFarm5kEnabled and task.wait() do
        pcall(function()
            local dummies = workspace.MAP["5k_dummies"]:GetChildren()
            local targetDummy = nil
            local shortestDistance = math.huge
            
            for _, dummy in pairs(dummies) do
                if dummy.Name == "Dummy2" then
                    if dummy:FindFirstChild("Humanoid") and dummy:FindFirstChild("HumanoidRootPart") then
                        local isOccupied = false
                        local dummyRoot = dummy.HumanoidRootPart
                        
                        for _, player in pairs(game.Players:GetPlayers()) do
                            if player.Character and player ~= game.Players.LocalPlayer then
                                local playerRoot = player.Character:FindFirstChild("HumanoidRootPart")
                                if playerRoot and (playerRoot.Position - dummyRoot.Position).Magnitude < 10 then
                                    isOccupied = true
                                    break
                                end
                            end
                        end
                        
                        if not isOccupied then
                            local distance = (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - dummyRoot.Position).Magnitude
                            if distance < shortestDistance then
                                shortestDistance = distance
                                targetDummy = dummy
                            end
                        end
                    end
                end
            end
            
            if targetDummy and game.Players.LocalPlayer.Character then
                local humanoid = targetDummy:FindFirstChild("Humanoid")
                local rootPart = targetDummy:FindFirstChild("HumanoidRootPart")
                local playerRoot = game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                
                if humanoid and rootPart and playerRoot then
                    playerRoot.CFrame = rootPart.CFrame * CFrame.new(0, 8, 0)
                    game:GetService("ReplicatedStorage").jdskhfsIIIllliiIIIdchgdIiIIIlIlIli:FireServer(humanoid, 1)
                end
            end
        end)
    end
end

--[[
    FARM TAB UI
]]

-- Coin Farm Toggle
Tabs.Farm:Toggle({
    Title = "ðŸ’° Coin Farm",
    Desc = "Automatically farms coins",
    Value = false,
    Callback = function(state)
        isFarming = state
        
        if isFarming then
            task.spawn(coinFarmLoop)
            WindUI:Notify({
                Title = "ðŸ’° Coin Farm Activated",
                Content = "Coin Farm has been activated.",
                Duration = 1
            })
        else
            WindUI:Notify({
                Title = "ðŸ’° Coin Farm Deactivated",
                Content = "Coin Farm has been deactivated.",
                Duration = 1
            })
        end
    end
})

-- Attack All Bosses Toggle
Tabs.Farm:Toggle({
    Title = "ðŸ‘¹ Attack All Bosses",
    Desc = "Automatically attacks all bosses",
    Value = false,
    Callback = function(state)
        _G.attackAllNPCToggle = state
        
        if state then
            task.spawn(attackAllNPCsLoop)
        end
        
        WindUI:Notify({
            Title = "ðŸ‘¹ Attack All Bosses",
            Content = state and "Auto attack on all bosses has been activated!" or "Auto attack on all bosses has been deactivated!",
            Duration = 1
        })
    end
})

-- Dummy Farm Toggle
Tabs.Farm:Toggle({
    Title = "ðŸ§ðŸ» Dummy Farm",
    Desc = "Automatically farms dummies",
    Value = false,
    Callback = function(state)
        dummyFarmActive = state
        dummyFarmFunction()
        
        WindUI:Notify({
            Title = "ðŸ§ðŸ» Dummy Farm " .. (state and "Activated" or "Deactivated"),
            Content = state and "Dummy Farm has been activated!" or "Dummy Farm has been deactivated!",
            Duration = 1
        })
    end
})

-- Dummy 5k Farm Toggle
Tabs.Farm:Toggle({
    Title = "ðŸ§ðŸ» Dummy 5k Farm",
    Desc = "Automatically farms 5k dummies",
    Value = false,
    Callback = function(state)
        _G.dummyFarm5kEnabled = state
        
        if state then
            task.spawn(dummy5kFarmLoop)
        end
        
        WindUI:Notify({
            Title = "ðŸ§ðŸ» Dummy 5k Farm " .. (state and "Activated" or "Deactivated"),
            Content = state and "Dummy 5k Farm has been activated!" or "Dummy 5k Farm has been deactivated!",
            Duration = 1
        })
    end
})

-- Free Radio Toggle
Tabs.Farm:Toggle({
    Title = "ðŸ“» Free Radio", 
    Desc = nil,
    Value = false,
    Callback = function(state)
        local gui = game.Players.LocalPlayer:FindFirstChild("PlayerGui")
        if gui and gui:FindFirstChild("DRadio_Gui") then
            gui.DRadio_Gui.Enabled = state
        end
        
        WindUI:Notify({
            Title = "ðŸ“» Free Radio",
            Content = state and "Free Radio has been activated!" or "Free Radio has been deactivated!",
            Duration = 1
        })
    end
})

-- Visual 13x Exp Toggle
Tabs.Farm:Toggle({
    Title = "ðŸ” Visual 13x Exp", 
    Desc = nil,
    Value = false,
    Callback = function(state)
        local gui = game.Players.LocalPlayer:FindFirstChild("PlayerGui")
        if gui and gui:FindFirstChild("LevelBar") and gui.LevelBar:FindFirstChild("gamepassText") then
            gui.LevelBar.gamepassText.Visible = state
            if state then
                gui.LevelBar.gamepassText.Text = "13x exp"
            end
        end
        
        WindUI:Notify({
            Title = "ðŸ” Visual 13x Exp",
            Content = state and "13x Exp has been activated!" or "13x Exp has been deactivated!",
            Duration = 1
        })
    end
})

--[[
    PVP TAB FUNCTIONS
]]

-- Auto Eat function
local function autoEatLoop()
    local VirtualInputManager = game:GetService("VirtualInputManager")
    
    while autoEat and task.wait(1) do
        pcall(function()
            -- Select food slot
            VirtualInputManager:SendKeyEvent(true, "One", false, game)
            task.wait(0.1)
            VirtualInputManager:SendKeyEvent(false, "One", false, game)
            task.wait(0.1)

            -- Click at screen center
            local screenCenterX = workspace.CurrentCamera.ViewportSize.X * 0.5
            local screenCenterY = workspace.CurrentCamera.ViewportSize.Y * 0.7
            
            VirtualInputManager:SendMouseButtonEvent(screenCenterX, screenCenterY, 0, true, game, 0)
            task.wait(0.05)
            VirtualInputManager:SendMouseButtonEvent(screenCenterX, screenCenterY, 0, false, game, 0)
        end)
    end
end

-- Kill Aura function
local function killAuraLoop()
    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local localPlayer = Players.LocalPlayer

    while _G.killAura and task.wait(0.01) do
        pcall(function()
            for _, player in ipairs(Players:GetPlayers()) do
                if player ~= localPlayer and player.Character then
                    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
                    if humanoid and humanoid.Health > 0 and not player.Character:FindFirstChild("SafeZoneShield") then
                        local args = {
                            [1] = humanoid,
                            [2] = 5
                        }
                        ReplicatedStorage.jdskhfsIIIllliiIIIdchgdIiIIIlIlIli:FireServer(unpack(args))
                    end
                end
            end
        end)
    end
end

-- Loop Kill All function
local function loopKillAllPlayers()
    local localPlayer = game.Players.LocalPlayer

    while _G.huntPlayers and task.wait() do
        pcall(function()
            for _, target in ipairs(game.Players:GetPlayers()) do
                if target ~= localPlayer and target.Character and target.Character:FindFirstChild("Humanoid") and 
                   target.Character.Humanoid.Health > 1 and not target.Character:FindFirstChild("SafeZoneShield") then

                    local targetRoot = target.Character:FindFirstChild("HumanoidRootPart")
                    local localRoot = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")

                    if targetRoot and localRoot then
                        if (localRoot.Position - targetRoot.Position).Magnitude > 10 then
                            localRoot.CFrame = targetRoot.CFrame
                        end

                        local startTime = tick()

                        while target.Character and target.Character:FindFirstChild("Humanoid") and 
                              target.Character.Humanoid.Health > 1 and _G.huntPlayers do

                            if tick() - startTime > 8 then
                                break
                            end

                            local carryArgs = {
                                [1] = target,
                                [2] = "request_accepted"
                            }
                            game:GetService("ReplicatedStorage").Events.CarryEvent:FireServer(unpack(carryArgs))

                            local attackArgs = {
                                [1] = target.Character.Humanoid,
                                [2] = 24
                            }
                            game:GetService("ReplicatedStorage").jdskhfsIIIllliiIIIdchgdIiIIIlIlIli:FireServer(unpack(attackArgs))

                            task.wait()
                        end
                    end
                end
            end
        end)
    end
end

-- Auto Kill Low Levels function
local function autoKillLowLevels()
    local lp = game.Players.LocalPlayer

    while _G.farmLowLevels and task.wait() do
        pcall(function()
            local best = nil
            for _, p in ipairs(game.Players:GetPlayers()) do
                if p ~= lp and p.Character and p:FindFirstChild("leaderstats") and 
                   p.leaderstats.Level.Value < lp.leaderstats.Level.Value and 
                   p.Character:FindFirstChild("HumanoidRootPart") and 
                   p.Character:FindFirstChild("Humanoid") and 
                   p.Character.Humanoid.Health > 1 and 
                   not p.Character:FindFirstChild("SafeZoneShield") and 
                   (not best or p.leaderstats.Level.Value < best.leaderstats.Level.Value) then 
                    best = p 
                end
            end

            if best and lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") then
                local lr, tr = lp.Character.HumanoidRootPart, best.Character.HumanoidRootPart
                if (lr.Position - tr.Position).Magnitude > 10 then 
                    lr.CFrame = tr.CFrame 
                end
                
                game:GetService("ReplicatedStorage").Events.CarryEvent:FireServer(best, "request_accepted")
                game:GetService("ReplicatedStorage").jdskhfsIIIllliiIIIdchgdIiIIIlIlIli:FireServer(best.Character.Humanoid, 24)
            end
        end)
    end
end

--[[
    PVP TAB UI
]]

-- Auto Eat Toggle
Tabs.PVP:Toggle({
    Title = "ðŸŸ Auto Eat (PC)",
    Desc = "Enables or disables the Auto Eat function",
    Value = false,
    Callback = function(state)
        autoEat = state
        if autoEat then
            task.spawn(autoEatLoop)
        end
        
        WindUI:Notify({
            Title = "ðŸŸ Auto Eat",
            Content = state and "Auto Eat has been activated." or "Auto Eat has been deactivated.",
            Duration = 1
        })
    end
})

-- Kill Aura Toggle
Tabs.PVP:Toggle({
    Title = "âš”ï¸ Kill Aura",
    Desc = "Enables or disables the Kill Aura function",
    Value = false,
    Callback = function(state)
        _G.killAura = state
        if state then
            task.spawn(killAuraLoop)
        end
        
        WindUI:Notify({
            Title = "âš”ï¸ Kill Aura " .. (state and "Activated" or "Deactivated"),
            Content = state and "Kill Aura is now active." or "Kill Aura is now inactive.",
            Duration = 1
        })
    end
})

-- Loop Kill All Toggle
Tabs.PVP:Toggle({
    Title = "ðŸ¤¯ Loop Kill All Players",
    Desc = "Automatically hunts and kills all players",
    Value = false,
    Callback = function(state)
        _G.huntPlayers = state
        if state then
            task.spawn(loopKillAllPlayers)
        end
        
        WindUI:Notify({
            Title = state and "ðŸ¤¯ Loop Kill Activated" or "ðŸ›‘ Loop Kill Stopped",
            Content = state and "Now hunting all players!" or "Stopped hunting players.",
            Duration = 1
        })
    end
})

-- Auto Kill Low Levels Toggle
Tabs.PVP:Toggle({
    Title = "ðŸ˜Ž Auto Kill Low Levels",
    Desc = "Automatically hunts players with a lower level than you",
    Value = false,
    Callback = function(state)
        _G.farmLowLevels = state
        if state then
            task.spawn(autoKillLowLevels)
        end
        
        WindUI:Notify({
            Title = state and "ðŸ˜Ž Auto Kill Low Levels Activated" or "ðŸ›‘ Auto Kill Low Levels Stopped",
            Content = state and "Hunting lower-level players!" or "Stopped hunting low-level players.",
            Duration = 1
        })
    end
})

-- Free Fireball Button
Tabs.PVP:Button({
    Title = "ðŸ”¥ Free Fireball",
    Desc = "Click to get a fireball!",
    Callback = function()
        local tool = Instance.new("Tool")
        tool.Name = "Fireball"
        tool.RequiresHandle = false

        tool.Activated:Connect(function()
            local mouse = game.Players.LocalPlayer:GetMouse()
            local args = {
                [1] = mouse.Hit.p,
                [2] = "NewFireball"
            }
            game:GetService("ReplicatedStorage").SkillsInRS.RemoteEvent:FireServer(unpack(args))
        end)

        tool.Parent = game.Players.LocalPlayer.Backpack
        
        WindUI:Notify({
            Title = "ðŸ”¥ Fireball Created",
            Content = "The Fireball has been added to your backpack!",
            Duration = 1
        })
    end
})

-- Free Lightningball Button
Tabs.PVP:Button({
    Title = "âš¡ Free Lightningball",
    Desc = "Click to get a Lightning Ball!",
    Callback = function()
        local tool = Instance.new("Tool")
        tool.Name = "Lightning Ball"
        tool.RequiresHandle = false

        tool.Activated:Connect(function()
            local mouse = game.Players.LocalPlayer:GetMouse()
            for i = 1, 3 do
                local args = {
                    [1] = mouse.Hit.p,
                    [2] = "NewLightningball"
                }
                game:GetService("ReplicatedStorage").SkillsInRS.RemoteEvent:FireServer(unpack(args))
                task.wait(0.1)
            end
        end)

        tool.Parent = game.Players.LocalPlayer.Backpack
        
        WindUI:Notify({
            Title = "âš¡ Lightningball Created",
            Content = "The Lightningball has been added to your backpack!",
            Duration = 1
        })
    end
})

--[[
    PLAYER TELEPORT SYSTEM
]]

-- Player List Functions
local function getPlayers()
    local players = {"NinguÃ©m"} -- Always start with "NinguÃ©m" as first option
    for _, player in ipairs(game:GetService("Players"):GetPlayers()) do
        if player ~= game.Players.LocalPlayer then
            table.insert(players, player.Name)
        end
    end
    return players
end

local function updateTeleportDropdown()
    local players = getPlayers()
    
    if TeleportDropdown then
        local currentSelection = TeleportConfig.SelectedPlayer
        local selectionExists = false
        
        for _, player in ipairs(players) do
            if player == currentSelection then
                selectionExists = true
                break
            end
        end
        
        TeleportDropdown:Refresh(players)
        
        if not selectionExists or currentSelection == nil then
            TeleportDropdown:Select("NinguÃ©m")
            TeleportConfig.SelectedPlayer = "NinguÃ©m"
        else
            TeleportDropdown:Select(currentSelection)
        end
    end
end

local TeleportConfig = {
    SelectedPlayer = "NinguÃ©m"
}

-- Teleport Dropdown
TeleportDropdown = Tabs.PVP:Dropdown({
    Title = "ðŸ™‹ðŸ» Teleport to Player",
    Desc = "Select a player to teleport to",
    Values = getPlayers(),
    Multi = false,
    Default = "NinguÃ©m",
    Callback = function(selectedPlayer)
        TeleportConfig.SelectedPlayer = selectedPlayer
        
        if selectedPlayer == "NinguÃ©m" then 
            WindUI:Notify({
                Title = "Teleport",
                Content = "No player selected",
                Duration = 1
            })
            return 
        end
        
        local localPlayer = game:GetService("Players").LocalPlayer
        local targetPlayer = game:GetService("Players"):FindFirstChild(selectedPlayer)

        if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
            if localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
                localPlayer.Character:SetPrimaryPartCFrame(targetPlayer.Character.HumanoidRootPart.CFrame)
                
                WindUI:Notify({
                    Title = "ðŸ™‹ðŸ» Teleport Successful",
                    Content = "You have successfully teleported to " .. targetPlayer.Name .. "!",
                    Duration = 1
                })
            end
        else
            WindUI:Notify({
                Title = "Error",
                Content = "Player not found or invalid target!",
                Duration = 1
            })
        end
    end
})

-- Clan/Team System (Corrected version)
local invitationEvent = RS:WaitForChild("invitationEvent")
local TeamsFolder = workspace:WaitForChild("Teams")
local teamList = {}
for _, team in ipairs(TeamsFolder:GetChildren()) do table.insert(teamList, team.Name) end
local selectedTeam = teamList[1] or "Default"
local autoJoin = false
local autoJoinThread = nil
local lastJoinedTeam = nil

local function refreshTeamList()
    teamList = {}
    for _, team in ipairs(TeamsFolder:GetChildren()) do table.insert(teamList, team.Name) end
    if #teamList == 0 then
        table.insert(teamList, "Default")
    end
    selectedTeam = teamList[1]
end

local teamDropdown = Tabs.PVP:Dropdown({
    Title = "Select Team",
    Desc = "Choose a team to join",
    Values = teamList,
    Multi = false,
    Default = selectedTeam,
    Callback = function(choice)
        if type(choice) == "table" then
            selectedTeam = choice[1] or tostring(choice)
        else
            selectedTeam = tostring(choice)
        end
    end
})

Tabs.PVP:Button({
    Title = "Join Selected Team",
    Desc = "Join the selected team",
    Callback = function()
        local teamName = selectedTeam
        if not teamName or teamName == "" then 
            WindUI:Notify({Title = "Team Join", Content = "No team selected!", Duration = 3})
            return 
        end
        
        local teamLeader = nil
        local clanIcon = ""
        
        local teamFolder = workspace.Teams:FindFirstChild(teamName)
        if teamFolder and teamFolder:FindFirstChild("leader") then
            teamLeader = teamFolder.leader.Value
            if teamLeader then
                local leaderPlayer = game:GetService("Players"):FindFirstChild(teamLeader)
                if leaderPlayer and leaderPlayer:FindFirstChild("ClanIcon") and leaderPlayer.ClanIcon.Value and leaderPlayer.ClanIcon.Value ~= "" then
                    clanIcon = leaderPlayer.ClanIcon.Value
                    WindUI:Notify({Title = "Team Join", Content = "Found clan icon: " .. clanIcon, Duration = 2})
                else
                    WindUI:Notify({Title = "Team Join", Content = "No clan icon found, using empty string", Duration = 2})
                    clanIcon = ""
                end
            else
                WindUI:Notify({Title = "Team Join", Content = "Could not find team leader, using empty string", Duration = 2})
                clanIcon = ""
            end
        else
            WindUI:Notify({Title = "Team Join", Content = "Could not find team folder or leader, using empty string", Duration = 2})
            clanIcon = ""
        end
        
        local currentTeam = nil
        if plr:FindFirstChild("Clan") and plr.Clan.Value then
            currentTeam = plr.Clan.Value
        end
        if currentTeam and currentTeam ~= teamName then
            local leaveArgs = {
                {
                    action = "leave_clan"
                }
            }
            pcall(function()
                RS:WaitForChild("Events"):WaitForChild("ClanEvent"):FireServer(unpack(leaveArgs))
            end)
            task.wait(0.5)
        end
        
        WindUI:Notify({Title = "Team Join", Content = "Attempting to join: " .. teamName .. " with icon: " .. clanIcon, Duration = 3})
        
        local success = false
        
        pcall(function()
            local args = {
                {
                    teamIcon = clanIcon,
                    action = "accepted",
                    teamName = teamName
                }
            }
            RS:WaitForChild("invitationEvent"):FireServer(unpack(args))
            success = true
        end)
        
        if not success then
            pcall(function()
                local args = {
                    {
                        teamIcon = clanIcon,
                        action = "accepted",
                        teamName = teamName
                    },
                    teamName
                }
                RS:WaitForChild("invitationEvent"):FireServer(unpack(args))
                success = true
            end)
        end
        
        if not success then
            pcall(function()
                RS:WaitForChild("invitationEvent"):FireServer(teamName)
                success = true
            end)
        end
        
        if success then
            lastJoinedTeam = teamName
            WindUI:Notify({Title = "Team Join", Content = "Successfully attempted to join: " .. teamName, Duration = 3})
        else
            WindUI:Notify({Title = "Team Join", Content = "Failed to join team: " .. teamName, Duration = 3})
        end
    end
})

Tabs.PVP:Toggle({
    Title = "Auto Join",
    Desc = "Automatically stay in the selected team",
    Value = false,
    Callback = function(state)
        autoJoin = state
        if autoJoin then
            if autoJoinThread then return end
            autoJoinThread = task.spawn(function()
                while autoJoin do
                    if selectedTeam then
                        local teamLeader = nil
                        local clanIcon = ""
                        
                        local teamFolder = workspace.Teams:FindFirstChild(selectedTeam)
                        if teamFolder and teamFolder:FindFirstChild("leader") then
                            teamLeader = teamFolder.leader.Value
                            if teamLeader then
                                local leaderPlayer = game:GetService("Players"):FindFirstChild(teamLeader)
                                if leaderPlayer and leaderPlayer:FindFirstChild("ClanIcon") and leaderPlayer.ClanIcon.Value and leaderPlayer.ClanIcon.Value ~= "" then
                                    clanIcon = leaderPlayer.ClanIcon.Value
                                else
                                    clanIcon = ""
                                end
                            else
                                clanIcon = ""
                            end
                        else
                            clanIcon = ""
                        end
                        
                        if lastJoinedTeam and lastJoinedTeam ~= selectedTeam then
                            local leaveArgs = {[1] = { ["action"] = "leave_clan" }}
                            local clanEvent = RS:FindFirstChild("Events") and RS.Events:FindFirstChild("ClanEvent")
                            if clanEvent then clanEvent:FireServer(unpack(leaveArgs)) end
                        end
                        local args = {
                            {
                                teamIcon = clanIcon,
                                action = "accepted",
                                teamName = selectedTeam
                            }
                        }
                        RS:WaitForChild("invitationEvent"):FireServer(unpack(args))
                        lastJoinedTeam = selectedTeam
                    end
                    task.wait(1)
                end
            end)
        else
            autoJoinThread = nil
        end
    end
})

-- ESP System
local function InitializeESPStorage()
    if not ESPStorage then
        ESPStorage = Instance.new("Folder")
        ESPStorage.Name = "ESP_Storage"
        ESPStorage.Parent = game:GetService("CoreGui")
    end
end

local function CreateESP(player)
    if not ESPStorage or not ESPConfig.Enabled then return end
    
    local highlight = Instance.new("Highlight")
    highlight.Name = player.Name
    highlight.FillColor = ESPConfig.FillColor
    highlight.DepthMode = ESPConfig.DepthMode
    highlight.FillTransparency = ESPConfig.FillTransparency
    highlight.OutlineColor = ESPConfig.OutlineColor
    highlight.OutlineTransparency = ESPConfig.OutlineTransparency
    highlight.Parent = ESPStorage

    if player.Character then
        highlight.Adornee = player.Character
    end

    ESPConnections[player] = player.CharacterAdded:Connect(function(character)
        highlight.Adornee = character
    end)
end

local function RemoveESP(player)
    if ESPStorage then
        local esp = ESPStorage:FindFirstChild(player.Name)
        if esp then
            esp:Destroy()
        end
    end
    
    if ESPConnections[player] then
        ESPConnections[player]:Disconnect()
        ESPConnections[player] = nil
    end
end

local function ToggleESP(state)
    ESPConfig.Enabled = state
    
    if state then
        InitializeESPStorage()
        for _, player in ipairs(game:GetService("Players"):GetPlayers()) do
            if player ~= game.Players.LocalPlayer then
                CreateESP(player)
            end
        end
    else
        for player, _ in pairs(ESPConnections) do
            RemoveESP(player)
        end
        
        if ESPStorage then
            ESPStorage:Destroy()
            ESPStorage = nil
        end
    end
    
    WindUI:Notify({
        Title = "ðŸ‘ï¸ ESP Players",
        Content = state and "ESP Activated!" or "ESP Deactivated!",
        Duration = 1
    })
end

Tabs.PVP:Toggle({
    Title = "ðŸ‘ï¸ ESP Players",
    Desc = "Toggle to activate or deactivate ESP for players",
    Value = false,
    Callback = function(state)
        ToggleESP(state)
    end
})

-- Walk Speed Slider
local function updateWalkSpeed(speed)
    local character = game.Players.LocalPlayer.Character
    if character and character:FindFirstChildOfClass("Humanoid") then
        character.Humanoid.WalkSpeed = speed
    end
end

local function delayedNotification()
    if WalkSpeedConfig.Debounce then return end
    WalkSpeedConfig.Debounce = true
    
    task.wait(1) -- Wait 1 second after last slider movement
    
    WindUI:Notify({
        Title = "ðŸš€ Speed Adjustment",
        Content = "Your walk speed has been set to " .. WalkSpeedConfig.CurrentSpeed .. "!",
        Duration = 1
    })
    
    WalkSpeedConfig.Debounce = false
end

Tabs.PVP:Slider({
    Title = "ðŸš€ Walk Speed",
    Desc = "Adjust your character's movement speed",
    Value = {
        Min = WalkSpeedConfig.MinSpeed,
        Max = WalkSpeedConfig.MaxSpeed,
        Default = WalkSpeedConfig.CurrentSpeed
    },
    Callback = function(value)
        WalkSpeedConfig.CurrentSpeed = value
        updateWalkSpeed(value)
        task.spawn(delayedNotification)
    end
})

-- Character connection to maintain speed on respawn
game:GetService("Players").LocalPlayer.CharacterAdded:Connect(function(character)
    if WalkSpeedConfig.CurrentSpeed > WalkSpeedConfig.MinSpeed then
        character:WaitForChild("Humanoid")
        updateWalkSpeed(WalkSpeedConfig.CurrentSpeed)
    end
end)

-- Teleport Locations
local function teleportTo(location)
    local character = game.Players.LocalPlayer.Character
    if character and character:FindFirstChild("HumanoidRootPart") then
        character.HumanoidRootPart.CFrame = CFrame.new(location.Position)
        
        WindUI:Notify({
            Title = location.Name,
            Content = "You have been teleported successfully!",
            Duration = 3
        })
    else
        WindUI:Notify({
            Title = "Error",
            Content = "Character not found or invalid!",
            Duration = 3
        })
    end
end

-- Create teleport buttons
for _, location in ipairs(TeleportLocations) do
    Tabs.Teleport:Button({
        Title = location.Name,
        Desc = "Teleport to " .. location.Name:gsub("%p", ""),
        Callback = function()
            teleportTo(location)
        end
    })
end

-- Admin Alerts
local function checkAdminStatus(player)
    local success, rank = pcall(function()
        return player:GetRankInGroup(AdminConfig.GroupId)
    end)
    
    if not success then return false, false end
    
    local isAdmin = rank >= AdminConfig.AdminRank
    local isModerator = not isAdmin and rank >= AdminConfig.ModeratorRank
    
    return isAdmin, isModerator
end

local function playerAdded(player)
    if not AdminConfig.AlertsEnabled then return end
    
    local isAdmin, isModerator = checkAdminStatus(player)
    
    if isAdmin or isModerator then
        local role = isAdmin and "Administrator" or "Moderator"
        
        WindUI:Notify({
            Title = "âš ï¸ Staff Join Alert",
            Content = player.Name .. " (" .. role .. ") has joined the game",
            Duration = 1
        })
    end
end

--[[
    MISC TAB - ADMIN ALERTS
]]

Tabs.Misc:Toggle({
    Title = "âš ï¸ Staff Join Alerts",
    Desc = "Get notifications when staff members join",
    Value = true,
    Callback = function(state)
        AdminConfig.AlertsEnabled = state
        WindUI:Notify({
            Title = "Staff Alerts",
            Content = state and "Staff join alerts enabled" or "Staff join alerts disabled",
            Duration = 1
        })
    end
})

-- Spectate System
local function updateSpectateDropdown()
    local players = getPlayers()
    
    if SpectateDropdown then
        local currentSelection = SpectateConfig.SelectedPlayer
        local selectionExists = false
        
        for _, player in ipairs(players) do
            if player == currentSelection then
                selectionExists = true
                break
            end
        end
        
        SpectateDropdown:Refresh(players)
        
        if not selectionExists or currentSelection == nil then
            SpectateDropdown:Select("NinguÃ©m")
            SpectateConfig.SelectedPlayer = "NinguÃ©m"
        else
            SpectateDropdown:Select(currentSelection)
        end
    end
end

local function startSpectating()
    if not SpectateConfig.SelectedPlayer or SpectateConfig.SelectedPlayer == "NinguÃ©m" then
        WindUI:Notify({
            Title = "Error",
            Content = "No player selected to spectate!",
            Duration = 3
        })
        return
    end

    local target = game:GetService("Players"):FindFirstChild(SpectateConfig.SelectedPlayer)
    if target and target.Character then
        local humanoidRootPart = target.Character:FindFirstChild("HumanoidRootPart")
        if humanoidRootPart then
            SpectateConfig.IsSpectating = true
            SpectateConfig.Camera.CameraSubject = humanoidRootPart
            
            WindUI:Notify({
                Title = "ðŸ§¿ Spectating",
                Content = "Now spectating " .. target.Name,
                Duration = 3
            })

            target.CharacterAdded:Connect(function(character)
                if SpectateConfig.IsSpectating then
                    character:WaitForChild("HumanoidRootPart")
                    SpectateConfig.Camera.CameraSubject = character.HumanoidRootPart
                end
            end)
        end
    else
        WindUI:Notify({
            Title = "Error",
            Content = "Player not found or invalid target!",
            Duration = 3
        })
    end
end

local function stopSpectating()
    SpectateConfig.IsSpectating = false
    local character = game.Players.LocalPlayer.Character
    if character then
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            SpectateConfig.Camera.CameraSubject = humanoid
        end
    end
    
    WindUI:Notify({
        Title = "ðŸ§¿ Spectating Stopped",
        Content = "No longer spectating",
        Duration = 3
    })
    
    if SpectateDropdown then
        SpectateDropdown:Select("NinguÃ©m")
        SpectateConfig.SelectedPlayer = "NinguÃ©m"
    end
end

-- Spectate Dropdown
SpectateDropdown = Tabs.Misc:Dropdown({
    Title = "ðŸ§¿ Spectate Player",
    Desc = "Select a player to spectate",
    Values = getPlayers(),
    Multi = false,
    Default = "NinguÃ©m",
    Callback = function(selected)
        SpectateConfig.SelectedPlayer = selected
        if selected ~= "NinguÃ©m" then
            WindUI:Notify({
                Title = "Player Selected",
                Content = "Ready to spectate: " .. selected,
                Duration = 2
            })
        end
    end
})

-- Spectate Buttons
Tabs.Misc:Button({
    Title = "â–¶ï¸ Start Spectating",
    Desc = "Begin spectating the selected player",
    Callback = startSpectating
})

Tabs.Misc:Button({
    Title = "â¹ï¸ Stop Spectating",
    Desc = "Stop spectating and return to your character",
    Callback = stopSpectating
})

-- Spam System
local function updateSpamDropdown()
    local players = getPlayers()
    if SpamDropdown then
        SpamDropdown:Refresh(players)
        if not table.find(players, SpamConfig.SelectedPlayer) then
            SpamConfig.SelectedPlayer = "NinguÃ©m"
            SpamDropdown:Select("NinguÃ©m")
        end
    end
end

local function startSpamming()
    if SpamConfig.SelectedPlayer == "NinguÃ©m" then
        WindUI:Notify({
            Title = "Error",
            Content = "No player selected to spam!",
            Duration = 1
        })
        return
    end

    SpamConfig.IsSpamming = true
    local target = game:GetService("Players"):FindFirstChild(SpamConfig.SelectedPlayer)
    
    if not target then
        WindUI:Notify({
            Title = "Error",
            Content = "Player not found!",
            Duration = 1
        })
        SpamConfig.IsSpamming = false
        return
    end

    WindUI:Notify({
        Title = "ðŸ—£ï¸ Spamming Started",
        Content = "Now spamming " .. target.Name,
        Duration = 1
    })

    while SpamConfig.IsSpamming and task.wait(SpamConfig.SpamDelay) do
        if not target or not game:GetService("Players"):FindFirstChild(SpamConfig.SelectedPlayer) then
            SpamConfig.IsSpamming = false
            SpamConfig.SelectedPlayer = "NinguÃ©m"
            updateSpamDropdown()
            WindUI:Notify({
                Title = "Error",
                Content = "Player left the game!",
                Duration = 1
            })
            break
        end

        local args = {
            [1] = {
                ["toolname"] = "RoseB",
                ["oplr"] = target,
                ["action"] = "give",
                ["gift"] = SpamConfig.SpamMessage,
            }
        }
        
        pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("GiveEvent"):FireServer(unpack(args))
        end)
    end
end

local function stopSpamming()
    SpamConfig.IsSpamming = false
    WindUI:Notify({
        Title = "ðŸ—£ï¸ Spamming Stopped",
        Content = "Stopped spamming " .. (SpamConfig.SelectedPlayer ~= "NinguÃ©m" and SpamConfig.SelectedPlayer or ""),
        Duration = 1
    })
end

-- Spam Dropdown
SpamDropdown = Tabs.Misc:Dropdown({
    Title = "ðŸ—£ï¸ Spam Target Player",
    Desc = "Select a player to spam",
    Values = getPlayers(),
    Multi = false,
    Default = "NinguÃ©m",
    Callback = function(selected)
        SpamConfig.SelectedPlayer = selected
        if selected ~= "NinguÃ©m" then
            WindUI:Notify({
                Title = "Player Selected",
                Content = "Ready to spam: " .. selected,
                Duration = 1
            })
        end
    end
})

-- Spam Buttons
Tabs.Misc:Button({
    Title = "â–¶ï¸ Start Spamming",
    Desc = "Begin spamming the selected player",
    Callback = startSpamming
})

Tabs.Misc:Button({
    Title = "â¹ï¸ Stop Spamming",
    Desc = "Stop spamming the selected player",
    Callback = stopSpamming
})

-- Misc Buttons
Tabs.Misc:Button({
    Title = "ðŸ—£ï¸ Unban Voice Chat",
    Desc = "Click to remove your voice chat ban",
    Callback = function()
        local success, err = pcall(function()
            game:GetService("VoiceChatService"):JoinVoiceChat()
        end)
        
        if success then
            WindUI:Notify({
                Title = "ðŸ—£ï¸ Voice Chat Unbanned",
                Content = "Your voice chat has been unbanned!",
                Duration = 1
            })
        else
            WindUI:Notify({
                Title = "Error",
                Content = "Failed to unban voice chat: " .. tostring(err),
                Duration = 1
            })
        end
    end
})

Tabs.Misc:Button({
    Title = "â˜ ï¸ Fling",
    Desc = "Carry someone, enable this, then release to fling them",
    Callback = function()
        local success, err = pcall(function()
            loadstring(game:HttpGet("https://raw.githubusercontent.com/nick0022/walkflinng/refs/heads/main/README.md", true))()
        end)
        
        if success then
            WindUI:Notify({
                Title = "â˜ ï¸ Fling Activated",
                Content = "The fling script has been executed successfully!",
                Duration = 1
            })
        else
            WindUI:Notify({
                Title = "Error",
                Content = "Failed to load fling script: " .. tostring(err),
                Duration = 1
            })
        end
    end
})

Tabs.Misc:Button({
    Title = "ðŸ•³ï¸ Void Player",
    Desc = "Carry a player, activate this, then drop them into the void",
    Callback = function()
        local player = game.Players.LocalPlayer
        local character = player.Character
        
        if not character or not character.PrimaryPart then
            WindUI:Notify({
                Title = "Error",
                Content = "Character not found or invalid!",
                Duration = 1
            })
            return
        end

        local originalPosition = character.PrimaryPart.Position
        local voidPosition = originalPosition - Vector3.new(0, 500, 0)

        WindUI:Notify({
            Title = "ðŸ•³ï¸ Void Player",
            Content = "Preparing void teleport...",
            Duration = 1
        })

        character:SetPrimaryPartCFrame(CFrame.new(voidPosition))

        WindUI:Notify({
            Title = "ðŸ•³ï¸ Void Player",
            Content = "Player sent to void! Releasing in 3 seconds...",
            Duration = 3
        })

        task.wait(3)
        
        if character and character.PrimaryPart then
            character:SetPrimaryPartCFrame(CFrame.new(originalPosition))
            WindUI:Notify({
                Title = "ðŸ•³ï¸ Void Player",
                Content = "Player returned from void!",
                Duration = 1
            })
        else
            WindUI:Notify({
                Title = "Error",
                Content = "Character became invalid during process!",
                Duration = 1
            })
        end
    end
})

-- Scripts Tab
Tabs.Scripts:Button({
    Title = "ðŸ“„ Infinity Yield",
    Desc = "Execute the Infinity Yield script",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source"))()
        WindUI:Notify({
            Title = "ðŸ“„ Infinity Yield",
            Content = "The Infinity Yield script has been executed successfully!",
            Duration = 1
        })
    end
})

Tabs.Scripts:Button({
    Title = "ðŸ“„ Moon AntiAfk",
    Desc = "Execute the Moon AntiAfk script",
    Callback = function()
        loadstring(game:HttpGet('https://raw.githubusercontent.com/rodri0022/afkmoon/refs/heads/main/README.md', true))()
        WindUI:Notify({
            Title = "ðŸ“„ Moon AntiAfk",
            Content = "The Moon AntiAfk script has been executed!",
            Duration = 1
        })
    end
})

Tabs.Scripts:Button({
    Title = "ðŸ“„ Moon AntiLag",
    Desc = "Execute the Moon AntiLag script",
    Callback = function()
        loadstring(game:HttpGet('https://raw.githubusercontent.com/nick0022/antilag/refs/heads/main/README.md', true))()
        WindUI:Notify({
            Title = "ðŸ“„ Moon AntiLag",
            Content = "The Moon AntiLag script has been executed!",
            Duration = 1
        })
    end
})

Tabs.Scripts:Button({
    Title = "ðŸ“„ FE R15 Emotes and Animation",
    Desc = "Execute the FE R15 Emotes and Animation script",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/BeemTZy/Motiona/refs/heads/main/source.lua"))()
        WindUI:Notify({
            Title = "ðŸ“„ FE R15 Emotes and Animation",
            Content = "The FE R15 Emotes and Animation script has been executed!",
            Duration = 1
        })
    end
})

Tabs.Scripts:Button({
    Title = "ðŸ“„ Moon FE Emotes",
    Desc = "Execute the Moon Emotes script",
    Callback = function()
        loadstring(game:HttpGet('https://raw.githubusercontent.com/rodri0022/freeanimmoon/refs/heads/main/README.md', true))()
        WindUI:Notify({
            Title = "ðŸ“„ Moon Emotes",
            Content = "The Moon Emotes script has been executed!",
            Duration = 1
        })
    end
})

Tabs.Scripts:Button({
    Title = "ðŸ“„ Moon Troll",
    Desc = "Execute the Moon Troll script",
    Callback = function()
        loadstring(game:HttpGet('https://raw.githubusercontent.com/nick0022/trollscript/refs/heads/main/README.md'))()
        WindUI:Notify({
            Title = "ðŸ“„ Moon Troll",
            Content = "The Moon Troll script has been executed!",
            Duration = 1
        })
    end
})

Tabs.Scripts:Button({
    Title = "ðŸ“„ Sirius",
    Desc = "Execute the Sirius script",
    Callback = function()
        loadstring(game:HttpGet('https://sirius.menu/sirius'))()
        WindUI:Notify({
            Title = "ðŸ“„ Sirius",
            Content = "The Sirius script has been executed!",
            Duration = 1
        })
    end
})

Tabs.Scripts:Button({
    Title = "ðŸ“„ Keyboard",
    Desc = "Execute the Keyboard script",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/GGH52lan/GGH52lan/main/keyboard.txt"))()
        WindUI:Notify({
            Title = "ðŸ“„ Keyboard",
            Content = "The Keyboard script has been executed!",
            Duration = 1
        })
    end
})

Tabs.Scripts:Button({
    Title = "ðŸ“„ Shader",
    Desc = "Script para deixar seu jogo bonito.",
    Callback = function()
        loadstring(game:HttpGet('https://raw.githubusercontent.com/randomstring0/pshade-ultimate/refs/heads/main/src/cd.lua'))()
        WindUI:Notify({
            Title = "ðŸ“„ shader",
            Content = "o script shader foi executado!",
            Duration = 1
        })
    end
})

Tabs.Scripts:Button({
    Title = "ðŸ“„ ChatBypass",
    Desc = "Script para deixar vocÃª mandar o que quiser no chat. Key: heypew",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/randomizedcomponent/UC/refs/heads/main/3307468c285f4fe535fb5d87b4b053e6.lua"))()
        WindUI:Notify({
            Title = "ðŸ“„ Chatbypass",
            Content = "o script Chatbypass foi executado!",
            Duration = 1
        })
    end
})

Tabs.Scripts:Button({
    Title = "ðŸ“„ SystemBroken",
    Desc = "Script parecido com esse",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/H20CalibreYT/SystemBroken/main/script"))()
        WindUI:Notify({
            Title = "ðŸ“„ systembroken",
            Content = "o script systembroken foi executado!",
            Duration = 1
        })
    end
})

-- Skins Tab
-- Christmas Skins Button
Tabs.Skins:Button({
    Title = "ðŸŽ…ðŸ» Christmas Skins",
    Desc = "Unlock all Christmas skins",
    Callback = function()
        local skins = {"XM24Fr", "XM24Fr", "XM24Bear", "XM24Eag", "XM24Br", "XM24Cr", "XM24Sq"}
        
        for _, skin in pairs(skins) do
            game:GetService("ReplicatedStorage").Events.SkinClickEvent:FireServer(skin, "v2")
            task.wait(0.1)
        end

        WindUI:Notify({
            Title = "ðŸŽ…ðŸ» Christmas Skins Unlocked",
            Content = "All Christmas skins have been successfully unlocked!",
            Duration = 3
        })
    end
})

-- Pig Skins Button
Tabs.Skins:Button({
    Title = "ðŸ· Pig Skins",
    Desc = "Unlock all Pig skins",
    Callback = function()
        local skins = {"PIG1", "PIG2", "PIG3", "PIG4", "PIG5", "PIG6", "PIG7", "PIG8"}
        
        for _, skin in pairs(skins) do
            game:GetService("ReplicatedStorage").Events.SkinClickEvent:FireServer(skin, "v2")
            task.wait(0.1)
        end

        WindUI:Notify({
            Title = "ðŸ· Pig Skins Unlocked",
            Content = "All Pig skins have been successfully unlocked!",
            Duration = 3
        })
    end
})

-- ServiÃ§os do Roblox
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

-- Defina as localizaÃ§Ãµes para facilitar a leitura
local localizacaoA = Vector3.new(-127.946053, 642.647949, 429.429596)
local localizacaoB = Vector3.new(-137.940262, 642.648254, 434.050598)

-- FunÃ§Ã£o para teleportar o jogador local com espera de 2 segundos ANTES
local function TeleportarJogador(posicao)
    -- Garante que sÃ³ roda no cliente
    if not RunService:IsClient() then return end 
    
    local player = Players.LocalPlayer
    if not player then return end 
    
    local character = player.Character or player.CharacterAdded:Wait()
    if not character then return end 

    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then 
        warn("HumanoidRootPart nÃ£o encontrado para teleporte.")
        return 
    end

    -- >>> Adiciona a espera de 2 segundos ANTES de teleportar <<<
    print("Aguardando 2 segundos antes do teleporte para: " .. tostring(posicao))
    task.wait(2) -- Espera por 2 segundos
    
    -- Realiza o teleporte
    print("Teleportando agora...")
    humanoidRootPart.CFrame = CFrame.new(posicao)
    
    -- Pequena espera APÃ“S o teleporte (pode ser Ãºtil para estabilizaÃ§Ã£o)
    task.wait(0.1) 
end

-- FunÃ§Ã£o para disparar o evento remoto (sem alteraÃ§Ãµes na espera interna)
local function DispararEventoPuzzle(numeroPuzzle)
    if not RunService:IsClient() then return end 

    local easterEventFolder = ReplicatedStorage:WaitForChild("Easter2025", 9e9) 
    if not easterEventFolder then
        warn("Pasta 'Easter2025' nÃ£o encontrada em ReplicatedStorage.")
        return
    end
    
    local remoteEvent = easterEventFolder:WaitForChild("RemoteEvent", 9e9) 
    if not remoteEvent then
        warn("RemoteEvent 'RemoteEvent' nÃ£o encontrado dentro de 'Easter2025'.")
        return
    end

    local args = {
        [1] = {
            ["action"] = "pick_up";
            ["puzzle_name"] = "PUZ" .. tostring(numeroPuzzle); 
        };
    }

    print("Disparando evento para: PUZ" .. tostring(numeroPuzzle))
    remoteEvent:FireServer(unpack(args))
    task.wait(0.1) -- Pequena espera apÃ³s disparar o evento
end

-- Cria o botÃ£o na UI
Tabs.Skins:Button({
    Title = "Easter Event Skins", -- Nome atualizado
    Desc = "Unlock all the skins for the 2025 Easter event", -- DescriÃ§Ã£o atualizada
    Callback = function()
        print("BotÃ£o clicado! Iniciando sequÃªncia com esperas de 2 segundos antes de cada teleporte...")

        -- Loop de 1 a 25
        for i = 1, 25 do
            print("--- Iniciando ciclo " .. i .. " ---")

            -- 1. Teleportar para LocalizaÃ§Ã£o A 
            --    (A funÃ§Ã£o TeleportarJogador agora contÃ©m a espera de 2s)
            TeleportarJogador(localizacaoA) 

            -- 2. Disparar Evento Remoto PUZi
            DispararEventoPuzzle(i) 

            -- 3. Teleportar para LocalizaÃ§Ã£o B
            --    (A funÃ§Ã£o TeleportarJogador agora contÃ©m a espera de 2s)
            TeleportarJogador(localizacaoB)

            -- 4. Teleportar de volta para LocalizaÃ§Ã£o A
            --    (A funÃ§Ã£o TeleportarJogador agora contÃ©m a espera de 2s)
            TeleportarJogador(localizacaoA)

            print("--- Ciclo " .. i .. " concluÃ­do ---")
            -- A pausa de 0.5s entre os ciclos completos foi removida, 
            -- pois os waits de 2s antes de cada teleporte jÃ¡ adicionam bastante tempo.
            -- Se ainda quiser uma pausa extra aqui, descomente a linha abaixo:
            -- task.wait(0.5) 
        end

        print("SequÃªncia com esperas completa!")
    end,
})

print("Easter event skins")

Tabs.Skins:Button({
    Title = "âš”ï¸ Secret Weapon",
    Desc = "Unlock a secret sword skin",
    Callback = function()
        local args = {
            [1] = "SSSSSSS2";
        }
        
        game:GetService("ReplicatedStorage"):WaitForChild("Events", 9e9):WaitForChild("WeaponEvent", 9e9):FireServer(unpack(args))

        WindUI:Notify({
            Title = "âš”ï¸ Secret Weapon Unlocked",
            Content = "Secret sword skin has been successfully unlocked!",
            Duration = 3
        })
    end
})

Tabs.Skins:Button({
    Title = "âš”ï¸ Secret Weapon2",
    Desc = "Unlock a secret sword skin",
    Callback = function()
        local args = {
            [1] = "SSSSSSS4";
        }
        
        game:GetService("ReplicatedStorage"):WaitForChild("Events", 9e9):WaitForChild("WeaponEvent", 9e9):FireServer(unpack(args))

        WindUI:Notify({
            Title = "âš”ï¸ Secret Weapon2 Unlocked",
            Content = "Secret sword skin has been successfully unlocked!",
            Duration = 3
        })
    end
})

Tabs.Skins:Button({
    Title = "âš”ï¸ Secret Weapon3",
    Desc = "Unlock a secret sword skin",
    Callback = function()
        local args = {
            [1] = "SSSS2";
        }
        
        game:GetService("ReplicatedStorage"):WaitForChild("Events", 9e9):WaitForChild("WeaponEvent", 9e9):FireServer(unpack(args))

        WindUI:Notify({
            Title = "âš”ï¸ Secret Weapon3 Unlocked",
            Content = "Secret sword skin has been successfully unlocked!",
            Duration = 3
        })
    end
})

Tabs.Skins:Button({
    Title = "âš”ï¸ Secret Weapon4",
    Desc = "Unlock a secret sword skin",
    Callback = function()
        local args = {
            [1] = "SSSS1";
        }
        
        game:GetService("ReplicatedStorage"):WaitForChild("Events", 9e9):WaitForChild("WeaponEvent", 9e9):FireServer(unpack(args))

        WindUI:Notify({
            Title = "âš”ï¸ Secret Weapon4 Unlocked",
            Content = "Secret sword skin has been successfully unlocked!",
            Duration = 3
        })
    end
})

--[[
    SETTINGS TAB
]]

-- Update Lists Button
local function manualUpdateAllDropdowns()
    updateTeleportDropdown()
    updateSpectateDropdown()
    updateSpamDropdown()
    
    WindUI:Notify({
        Title = "ðŸ”„ Lists Updated",
        Content = "All player lists have been updated!",
        Duration = 1
    })
end

Tabs.Settings:Button({
    Title = "ðŸ”„ Update Player Lists",
    Desc = "Click to manually update all player lists",
    Callback = manualUpdateAllDropdowns
})

Tabs.Settings:Button({
    Title = "ðŸ”ƒ Rejoin Game",
    Desc = "Rejoin the current game session",
    Callback = function()
        game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, game.JobId)
        WindUI:Notify({
            Title = "Rejoining Game",
            Content = "Attempting to rejoin the current session...",
            Duration = 1
        })
    end
})

Tabs.Settings:Section({ Title = "Window Configuration" })

local themeValues = {}
for name, _ in pairs(WindUI:GetThemes()) do
    table.insert(themeValues, name)
end

local themeDropdown = Tabs.Settings:Dropdown({
    Title = "Select Theme",
    Desc = "Change the UI theme",
    Values = themeValues,
    Multi = false,
    Default = WindUI:GetCurrentTheme(),
    Callback = function(theme)
        WindUI:SetTheme(theme)
    end
})

local transparencyToggle = Tabs.Settings:Toggle({
    Title = "Window Transparency",
    Desc = "Toggle window transparency effect",
    Value = WindUI:GetTransparency(),
    Callback = function(state)
        Window:ToggleTransparency(state)
    end
})

Tabs.Settings:Section({ Title = "Save/Load Configuration" })

local configName = ""

Tabs.Settings:Input({
    Title = "Configuration Name",
    Desc = "Enter a name for your config",
    Default = "",
    PlaceholderText = "MyConfig",
    Callback = function(text)
        configName = text
    end
})

local configFiles = listfiles("MoonHUB") or {}
local configDropdown = Tabs.Settings:Dropdown({
    Title = "Saved Configurations",
    Desc = "Select a configuration to load",
    Values = configFiles,
    Multi = false,
    Default = nil,
    Callback = function(selected)
        configName = selected
    end
})

Tabs.Settings:Button({
    Title = "ðŸ’¾ Save Configuration",
    Desc = "Save current settings to file",
    Callback = function()
        if configName ~= "" then
            -- Criar a pasta MoonHUB se nÃ£o existir
            if not isfolder("MoonHUB") then
                makefolder("MoonHUB")
            end
            
            local configData = {
                Theme = WindUI:GetCurrentTheme(),
                Transparency = WindUI:GetTransparency(),
                WalkSpeed = WalkSpeedConfig.CurrentSpeed,
                ESPEnabled = ESPConfig.Enabled,
                Keybind = tostring(currentKeybind) -- Alterado para usar currentKeybind
            }
            
            local success, err = pcall(function()
                writefile("MoonHUB/"..configName..".json", game:GetService("HttpService"):JSONEncode(configData))
            end)
            
            if success then
                WindUI:Notify({
                    Title = "Configuration Saved",
                    Content = "Settings saved as: "..configName,
                    Duration = 3
                })
                -- Atualizar a lista de configuraÃ§Ãµes
                configFiles = listfiles("MoonHUB") or {}
                configDropdown:Refresh(configFiles)
            else
                WindUI:Notify({
                    Title = "Error",
                    Content = "Failed to save config: "..tostring(err),
                    Duration = 3
                })
            end
        else
            WindUI:Notify({
                Title = "Error",
                Content = "Please enter a configuration name!",
                Duration = 2
            })
        end
    end
})

Tabs.Settings:Button({
    Title = "ðŸ“‚ Load Configuration",
    Desc = "Load settings from file",
    Callback = function()
        if configName ~= "" and isfile("MoonHUB/"..configName..".json") then
            local success, configData = pcall(function()
                return game:GetService("HttpService"):JSONDecode(readfile("MoonHUB/"..configName..".json"))
            end)
            
            if success and configData then
                -- Aplicar configuraÃ§Ãµes carregadas
                if configData.Theme then
                    WindUI:SetTheme(configData.Theme)
                    themeDropdown:Select(configData.Theme)
                end
                
                if configData.Transparency ~= nil then
                    Window:ToggleTransparency(configData.Transparency)
                    transparencyToggle:SetValue(configData.Transparency)
                end
                
                if configData.WalkSpeed then
                    WalkSpeedConfig.CurrentSpeed = configData.WalkSpeed
                    updateWalkSpeed(configData.WalkSpeed)
                end
                
                if configData.ESPEnabled ~= nil then
                    ToggleESP(configData.ESPEnabled)
                end
                
                if configData.Keybind then
                    currentKeybind = Enum.KeyCode[configData.Keybind]
                    Window:SetToggleKey(currentKeybind)
                    setupKeybindListener()
                end
                
                WindUI:Notify({
                    Title = "Configuration Loaded",
                    Content = "Settings loaded from: "..configName,
                    Duration = 3
                })
            else
                WindUI:Notify({
                    Title = "Error",
                    Content = "Failed to load config!",
                    Duration = 3
                })
            end
        else
            WindUI:Notify({
                Title = "Error",
                Content = "Config file not found!",
                Duration = 2
            })
        end
    end
})

Tabs.Settings:Button({
    Title = "ðŸ”„ Refresh Config List",
    Desc = "Update the list of saved configurations",
    Callback = function()
        configFiles = listfiles("MoonHUB") or {}
        configDropdown:Refresh(configFiles)
        WindUI:Notify({
            Title = "Config List Updated",
            Content = "Configuration list has been refreshed",
            Duration = 1
        })
    end
})

-- Corrigindo o sistema de dropdowns para evitar erros de nil
local function safeUpdateDropdown(dropdown, config, default)
    if dropdown and config then
        local players = getPlayers()
        local currentSelection = config.SelectedPlayer or default
        local selectionExists = table.find(players, currentSelection)
        
        dropdown:Refresh(players)
        dropdown:Select(selectionExists and currentSelection or default)
        config.SelectedPlayer = selectionExists and currentSelection or default
    end
end

local function updateTeleportDropdown()
    safeUpdateDropdown(TeleportDropdown, TeleportConfig, "NinguÃ©m")
end

local function updateSpectateDropdown()
    safeUpdateDropdown(SpectateDropdown, SpectateConfig, "NinguÃ©m")
end

local function updateSpamDropdown()
    safeUpdateDropdown(SpamDropdown, SpamConfig, "NinguÃ©m")
end

-- Initial updates
updateTeleportDropdown()
updateSpectateDropdown()
updateSpamDropdown()

-- Select first tab and show notification
WindUI:Notify({
    Title = "Script Fully Loaded!",
    Content = "Happy using, remembering that all functions are undetectable!",
    Duration = 10
})


local TargetedPlayer = nil

local TweenService = game:GetService("TweenService")

local Developer_IDs = {
    5427606840,
    9255614355
}
local DevTag_conns = {} 
local DevTag_guis = {} 


local function isDeveloper(player)
    if not player then return false end
    for _, id in ipairs(Developer_IDs) do
        if player.UserId == id then
            return true
        end
    end
    return false
end

local function DevTag_destroy(player)
    if not player then return end
    local userId = player.UserId
    if DevTag_conns[userId] then
        DevTag_conns[userId]:Disconnect()
        DevTag_conns[userId] = nil
    end
    if DevTag_guis[userId] and DevTag_guis[userId].Parent then
        DevTag_guis[userId]:Destroy()
        DevTag_guis[userId] = nil
    end
end

local function DevTag_make(char)
    local player = game:GetService("Players"):GetPlayerFromCharacter(char)
    if not player or not isDeveloper(player) then return end

    local head = char:WaitForChild("Head", 10)
    if not head then return end

    DevTag_destroy(player) 
    local userId = player.UserId

    local b = Instance.new("BillboardGui")
    b.Name = "DevTag"
    b.AlwaysOnTop = true
    b.Size = UDim2.new(1.5, 0, 0.42, 0)
    b.StudsOffset = Vector3.new(0, 3.5, 0)
    b.Adornee = head
    b.Parent = head
    DevTag_guis[userId] = b 

    local f = Instance.new("Frame")
    f.AnchorPoint = Vector2.new(0.5, 0.5)
    f.Position = UDim2.new(0.5, 0, 0.5, 0)
    f.Size = UDim2.new(1, 0, 1, 0)
    f.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    f.BackgroundTransparency = 0.15
    f.Parent = b

    local c = Instance.new("UICorner")
    c.CornerRadius = UDim.new(0, 20)
    c.Parent = f

    local s = Instance.new("UIStroke")
    s.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
    s.Thickness = 3
    s.Color = Color3.fromRGB(255, 0, 0)
    s.Parent = f

    local t = Instance.new("TextLabel")
    t.BackgroundTransparency = 1
    t.Size = UDim2.new(0.95, 0, 0.9, 0)
    t.Position = UDim2.new(0.5, 0, 0.5, 0)
    t.AnchorPoint = Vector2.new(0.5, 0.5)
    t.Font = Enum.Font.GothamBold
    t.Text = "DEVELOPER"
    t.TextScaled = true
    t.TextColor3 = Color3.fromRGB(255, 0, 0)
    t.TextStrokeTransparency = 0.5
    t.TextStrokeColor3 = Color3.new(0, 0, 0)
    t.Parent = f

    TweenService:Create(b, TweenInfo.new(1.5, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true), {StudsOffset = Vector3.new(0, 3.9, 0)}):Play()

    local currentTween
    -- Armazena a conexÃ£o na tabela usando o UserId
    DevTag_conns[userId] = game:GetService("RunService").RenderStepped:Connect(function()
        if not head or not head.Parent or not b.Parent then
            DevTag_destroy(player)
            return
        end
        local cam = workspace.CurrentCamera
        if not cam then return end
        local dist = (cam.CFrame.Position - head.Position).Magnitude
        local tr = dist < 25 and 0 or dist < 45 and (dist - 25) / 20 or 1
        local bg = 0.15 + tr
        if math.abs(f.BackgroundTransparency - bg) > 0.05 then
            if currentTween then currentTween:Cancel() end
            currentTween = TweenService:Create(f, TweenInfo.new(0.3), {BackgroundTransparency = bg})
            currentTween:Play()
            TweenService:Create(t, TweenInfo.new(0.3), {TextTransparency = tr}):Play()
            TweenService:Create(s, TweenInfo.new(0.3), {Transparency = tr}):Play()
        end
    end)
end

local function DevTag_setup(player)
    
    if not isDeveloper(player) then return end

    if player.Character then
        DevTag_make(player.Character)
    end
    player.CharacterAdded:Connect(DevTag_make)
   
    player.CharacterRemoving:Connect(function()
        DevTag_destroy(player)
    end)
end


for _, player in ipairs(game:GetService("Players"):GetPlayers()) do
    DevTag_setup(player)
end


game:GetService("Players").PlayerAdded:Connect(DevTag_setup)


game:GetService("Players").PlayerRemoving:Connect(function(player)
    if isDeveloper(player) then
        DevTag_destroy(player)
    end
end)